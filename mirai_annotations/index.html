<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `mirai_annotations` crate."><title>mirai_annotations - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-b0742ba02757f159.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="mirai_annotations" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.0-nightly (9322d183f 2024-10-14)" data-channel="nightly" data-search-js="search-e056c65ede92db13.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../mirai_annotations/index.html">mirai_<wbr>annotations</a><span class="version">1.12.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#macros">Crate Items</a></h3><ul class="block"><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>mirai_annotations</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/mirai_annotations/lib.rs.html#8-1129">source</a> </span></div><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">ยง</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.abstract_value.html" title="macro mirai_annotations::abstract_value">abstract_<wbr>value</a></div><div class="desc docblock-short">Provides a way to specify a value that should be treated abstractly by the verifier.
The concrete argument provides type information to the verifier and a meaning for
the expression when compiled by the rust compiler.</div></li><li><div class="item-name"><a class="macro" href="macro.add_tag.html" title="macro mirai_annotations::add_tag">add_tag</a></div><div class="desc docblock-short">Equivalent to a no op when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to associate (tag) the value with the given type.
Typically the type will be private to a scope so that only privileged code can add the tag.
Once added, a tag cannot be removed and the tagged value may not be modified.
To determine if a value has been tagged, use the has_tag! macro.</div></li><li><div class="item-name"><a class="macro" href="macro.assume.html" title="macro mirai_annotations::assume">assume</a></div><div class="desc docblock-short">Equivalent to a no op when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition unless it can
prove it to be false.</div></li><li><div class="item-name"><a class="macro" href="macro.assume_preconditions.html" title="macro mirai_annotations::assume_preconditions">assume_<wbr>preconditions</a></div><div class="desc docblock-short">Equivalent to a no op when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume that the preconditions of the next
function call have been met.
This is to be used when the precondition has been inferred and involves private state that
cannot be constrained by a normal assumption.
Note that it is bad style for an API to rely on preconditions that cannot be checked by the
caller, so this is only here for supporting legacy APIs.</div></li><li><div class="item-name"><a class="macro" href="macro.assume_unreachable.html" title="macro mirai_annotations::assume_unreachable">assume_<wbr>unreachable</a></div><div class="desc docblock-short">Equivalent to unreachable! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume that the annotation statement cannot be reached.</div></li><li><div class="item-name"><a class="macro" href="macro.assumed_postcondition.html" title="macro mirai_annotations::assumed_postcondition">assumed_<wbr>postcondition</a></div><div class="desc docblock-short">Equivalent to a no op when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition at the
point where it appears in a function, but to also add it a postcondition that can
be assumed by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.checked_assume.html" title="macro mirai_annotations::checked_assume">checked_<wbr>assume</a></div><div class="desc docblock-short">Equivalent to the standard assert! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition unless it can
prove it to be false.</div></li><li><div class="item-name"><a class="macro" href="macro.checked_assume_eq.html" title="macro mirai_annotations::checked_assume_eq">checked_<wbr>assume_<wbr>eq</a></div><div class="desc docblock-short">Equivalent to the standard assert_eq! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition unless it can
prove it to be false.</div></li><li><div class="item-name"><a class="macro" href="macro.checked_assume_ne.html" title="macro mirai_annotations::checked_assume_ne">checked_<wbr>assume_<wbr>ne</a></div><div class="desc docblock-short">Equivalent to the standard assert_ne! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition unless it can
prove it to be false.</div></li><li><div class="item-name"><a class="macro" href="macro.checked_postcondition.html" title="macro mirai_annotations::checked_postcondition">checked_<wbr>postcondition</a></div><div class="desc docblock-short">Equivalent to the standard assert! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to verify the condition at the
point where it appears in a function, but to also add it a postcondition that can
be assumed by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.checked_postcondition_eq.html" title="macro mirai_annotations::checked_postcondition_eq">checked_<wbr>postcondition_<wbr>eq</a></div><div class="desc docblock-short">Equivalent to the standard assert_eq! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to verify the condition at the
point where it appears in a function, but to also add it a postcondition that can
be assumed by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.checked_postcondition_ne.html" title="macro mirai_annotations::checked_postcondition_ne">checked_<wbr>postcondition_<wbr>ne</a></div><div class="desc docblock-short">Equivalent to the standard assert_ne! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to verify the condition at the
point where it appears in a function, but to also add it a postcondition that can
be assumed by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.checked_precondition.html" title="macro mirai_annotations::checked_precondition">checked_<wbr>precondition</a></div><div class="desc docblock-short">Equivalent to the standard assert! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition at the
point where it appears in a function, but to also add it a precondition that must
be verified by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.checked_precondition_eq.html" title="macro mirai_annotations::checked_precondition_eq">checked_<wbr>precondition_<wbr>eq</a></div><div class="desc docblock-short">Equivalent to the standard assert_eq! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition at the
point where it appears in a function, but to also add it a precondition that must
be verified by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.checked_precondition_ne.html" title="macro mirai_annotations::checked_precondition_ne">checked_<wbr>precondition_<wbr>ne</a></div><div class="desc docblock-short">Equivalent to the standard assert_ne! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition at the
point where it appears in a function, but to also add it a precondition that must
be verified by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.checked_verify.html" title="macro mirai_annotations::checked_verify">checked_<wbr>verify</a></div><div class="desc docblock-short">Equivalent to the standard assert! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to check the condition and
emit a diagnostic unless it can prove it to be true.</div></li><li><div class="item-name"><a class="macro" href="macro.checked_verify_eq.html" title="macro mirai_annotations::checked_verify_eq">checked_<wbr>verify_<wbr>eq</a></div><div class="desc docblock-short">Equivalent to the standard assert_eq! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to check the condition and
emit a diagnostic unless it can prove it to be true.</div></li><li><div class="item-name"><a class="macro" href="macro.checked_verify_ne.html" title="macro mirai_annotations::checked_verify_ne">checked_<wbr>verify_<wbr>ne</a></div><div class="desc docblock-short">Equivalent to the standard assert_eq! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to check the condition and
emit a diagnostic unless it can prove it to be true.</div></li><li><div class="item-name"><a class="macro" href="macro.debug_checked_assume.html" title="macro mirai_annotations::debug_checked_assume">debug_<wbr>checked_<wbr>assume</a></div><div class="desc docblock-short">Equivalent to the standard debug_assert! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition unless it can
prove it to be false.</div></li><li><div class="item-name"><a class="macro" href="macro.debug_checked_assume_eq.html" title="macro mirai_annotations::debug_checked_assume_eq">debug_<wbr>checked_<wbr>assume_<wbr>eq</a></div><div class="desc docblock-short">Equivalent to the standard debug_assert_eq! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition unless it can
prove it to be false.</div></li><li><div class="item-name"><a class="macro" href="macro.debug_checked_assume_ne.html" title="macro mirai_annotations::debug_checked_assume_ne">debug_<wbr>checked_<wbr>assume_<wbr>ne</a></div><div class="desc docblock-short">Equivalent to the standard debug_assert_ne! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition unless it can
prove it to be false.</div></li><li><div class="item-name"><a class="macro" href="macro.debug_checked_postcondition.html" title="macro mirai_annotations::debug_checked_postcondition">debug_<wbr>checked_<wbr>postcondition</a></div><div class="desc docblock-short">Equivalent to the standard debug_assert! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to verify the condition at the
point where it appears in a function, but to also add it a postcondition that can
be assumed by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.debug_checked_postcondition_eq.html" title="macro mirai_annotations::debug_checked_postcondition_eq">debug_<wbr>checked_<wbr>postcondition_<wbr>eq</a></div><div class="desc docblock-short">Equivalent to the standard debug_assert_eq! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to verify the condition at the
point where it appears in a function, but to also add it a postcondition that can
be assumed by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.debug_checked_postcondition_ne.html" title="macro mirai_annotations::debug_checked_postcondition_ne">debug_<wbr>checked_<wbr>postcondition_<wbr>ne</a></div><div class="desc docblock-short">Equivalent to the standard debug_assert_ne! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to verify the condition at the
point where it appears in a function, but to also add it a postcondition that can
be assumed by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.debug_checked_precondition.html" title="macro mirai_annotations::debug_checked_precondition">debug_<wbr>checked_<wbr>precondition</a></div><div class="desc docblock-short">Equivalent to the standard debug_assert! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition at the
point where it appears in a function, but to also add it a precondition that must
be verified by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.debug_checked_precondition_eq.html" title="macro mirai_annotations::debug_checked_precondition_eq">debug_<wbr>checked_<wbr>precondition_<wbr>eq</a></div><div class="desc docblock-short">Equivalent to the standard debug_assert_eq! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition at the
point where it appears in a function, but to also add it a precondition that must
be verified by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.debug_checked_precondition_ne.html" title="macro mirai_annotations::debug_checked_precondition_ne">debug_<wbr>checked_<wbr>precondition_<wbr>ne</a></div><div class="desc docblock-short">Equivalent to the standard debug_assert_ne! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition at the
point where it appears in a function, but to also add it a precondition that must
be verified by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.debug_checked_verify.html" title="macro mirai_annotations::debug_checked_verify">debug_<wbr>checked_<wbr>verify</a></div><div class="desc docblock-short">Equivalent to the standard debug_assert! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to check the condition and
emit a diagnostic unless it can prove it to be true.</div></li><li><div class="item-name"><a class="macro" href="macro.debug_checked_verify_eq.html" title="macro mirai_annotations::debug_checked_verify_eq">debug_<wbr>checked_<wbr>verify_<wbr>eq</a></div><div class="desc docblock-short">Equivalent to the standard debug_assert_eq! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to check the condition and
emit a diagnostic unless it can prove it to be true.</div></li><li><div class="item-name"><a class="macro" href="macro.debug_checked_verify_ne.html" title="macro mirai_annotations::debug_checked_verify_ne">debug_<wbr>checked_<wbr>verify_<wbr>ne</a></div><div class="desc docblock-short">Equivalent to the standard debug_assert_ne! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to check the condition and
emit a diagnostic unless it can prove it to be true.</div></li><li><div class="item-name"><a class="macro" href="macro.does_not_have_tag.html" title="macro mirai_annotations::does_not_have_tag">does_<wbr>not_<wbr>have_<wbr>tag</a></div><div class="desc docblock-short">Provides a way to check if a value has <em>not</em> been tagged with a type using add_tag!.
When compiled with an unmodified Rust compiler, this results in true.
When compiled with MIRAI, this will be true if none data flows into the argument of this
call has gone via a call to add_tag!.</div></li><li><div class="item-name"><a class="macro" href="macro.get_model_field.html" title="macro mirai_annotations::get_model_field">get_<wbr>model_<wbr>field</a></div><div class="desc docblock-short">Retrieves the value of the specified model field, or the given default value if the model field
is not set.
This function has no meaning outside of a verification
condition and should not be used with checked or debug_checked conditions.
For example: precondition!(get_model_field!(x, f) &gt; 1).</div></li><li><div class="item-name"><a class="macro" href="macro.has_tag.html" title="macro mirai_annotations::has_tag">has_tag</a></div><div class="desc docblock-short">Provides a way to check if a value has been tagged with a type, using the add_tag! macro.
When compiled with an unmodified Rust compiler, this results in true.
When compiled with MIRAI, this will be true if all data flows into the argument of this
call has gone via a call to add_tag!.</div></li><li><div class="item-name"><a class="macro" href="macro.postcondition.html" title="macro mirai_annotations::postcondition">postcondition</a></div><div class="desc docblock-short">Equivalent to a no op when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to verify the condition at the
point where it appears in a function, but to also add it a postcondition that can
be assumed by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.precondition.html" title="macro mirai_annotations::precondition">precondition</a></div><div class="desc docblock-short">Equivalent to a no op when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to assume the condition at the
point where it appears in a function, but to also add it a precondition that must
be verified by the caller of the function.</div></li><li><div class="item-name"><a class="macro" href="macro.result.html" title="macro mirai_annotations::result">result</a></div><div class="desc docblock-short">Provides a way to refer to the result value of an abstract or contract function without
specifying an actual value anywhere.
This macro expands to unimplemented!() unless the program is compiled with MIRAI.
It result should therefore not be assigned to a variable unless the assignment is contained
inside a specification macro argument list.
It may, however, be the return value of the function, which should never be called and
therefore unimplemented!() is the right behavior for it at runtime.</div></li><li><div class="item-name"><a class="macro" href="macro.set_model_field.html" title="macro mirai_annotations::set_model_field">set_<wbr>model_<wbr>field</a></div><div class="desc docblock-short">Sets the value of the specified model field.
A model field does not exist at runtime and is invisible to the Rust compiler.
This macro expands to nothing unless the program is compiled with MIRAI.</div></li><li><div class="item-name"><a class="macro" href="macro.tag_propagation_set.html" title="macro mirai_annotations::tag_propagation_set">tag_<wbr>propagation_<wbr>set</a></div><div class="desc docblock-short">Provide a way to create tag propagation sets. It is equivalent to bitwise-or of all its arguments.</div></li><li><div class="item-name"><a class="macro" href="macro.unrecoverable.html" title="macro mirai_annotations::unrecoverable">unrecoverable</a></div><div class="desc docblock-short">Terminates the program with a panic that is tagged as being an unrecoverable error.
Use this for errors that arise in correct programs due to external factors.
For example, if a file that is essential for running cannot be found for some reason.</div></li><li><div class="item-name"><a class="macro" href="macro.verify.html" title="macro mirai_annotations::verify">verify</a></div><div class="desc docblock-short">Equivalent to a no op when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to check the condition and
emit a diagnostic unless it can prove it to be true.</div></li><li><div class="item-name"><a class="macro" href="macro.verify_unreachable.html" title="macro mirai_annotations::verify_unreachable">verify_<wbr>unreachable</a></div><div class="desc docblock-short">Equivalent to unreachable! when used with an unmodified Rust compiler.
When compiled with MIRAI, this causes MIRAI to verify that the annotation statement cannot be reached.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">ยง</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.TagPropagation.html" title="enum mirai_annotations::TagPropagation">TagPropagation</a></div><div class="desc docblock-short">An enum type of controllable operations for MIRAI tag types.
In general, the result of the operation corresponding to an enum value will
get tagged with all of the tags of the operands.</div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">ยง</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.TAG_PROPAGATION_ALL.html" title="constant mirai_annotations::TAG_PROPAGATION_ALL">TAG_<wbr>PROPAGATION_<wbr>ALL</a></div><div class="desc docblock-short">A tag propagation set indicating a tag is propagated by all operations.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">ยง</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.TagPropagationSet.html" title="type mirai_annotations::TagPropagationSet">TagPropagation<wbr>Set</a></div><div class="desc docblock-short">A type used to specify how tag types transfer over operations. The type is an alias of <code>u128</code>.
Each bit of the bit vector controls the transfer function for an operation.
If a bit is set to one, the corresponding operation will propagate the tag.
If a bit is set to zero, the corresponding operation will block the tag.</div></li></ul></section></div></main></body></html>