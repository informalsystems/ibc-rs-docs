searchState.loadedDescShard("ibc_types_core_connection", 0, "IBC connection-related types.\nThis type is subject to future changes.\nclient error: <code>{0}</code>\nClientPaths contains a list of all of the connection paths …\nthe client state proof verification failed for client id …\nconnection end for identifier <code>{connection_id}</code> was never …\nno connection was found for the previous connection id …\nthe consensus proof verification failed (height: <code>{height}</code>…\nempty supported features\nConnectionEnd domain object could not be constructed out …\nempty supported versions\ninvalid client state: <code>{reason}</code>\nconsensus height claimed by the client on the other party …\ninvalid counterparty\nidentifier error: <code>{0}</code>\ninvalid connection proof error\nconnection state is unknown: <code>{state}</code>\nmissing client state\nmissing consensus height\nmissing counterparty\nmissing proof height\nno common version\nother error: <code>{description}</code>\nmalformed signer\nverifying connnection state error: <code>{0}</code>\nStores the identifier and the features supported by a …\nversion &quot;<code>{version}</code>&quot; not supported\nGet this identifier as a borrowed byte slice\nYields the State as a string.\nGet a reference to the underlying string.\nGet this identifier as a borrowed <code>&amp;str</code>\nExtract the version from the given chain identifier.\nHelper function to compare the client id of this end with …\nReturns the lists of supported versions\nHelper function to compare the counterparty of this end …\nTypes for ABCI <code>Event</code>s that inform relayers about IBC …\nlist of features compatible with the specified identifier\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParses the State out from a i32.\nunique version identifier\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nis_epoch_format() checks if a chain_id is in the format …\nHelper function to determine whether the connection is …\nReturns whether or not this connection state is <code>Open</code>.\nChecks whether or not the given feature is supported in …\nHelper function to determine whether the connection is …\nReturns whether or not this connection with this state has …\nMessage definitions for the connection handshake datagrams.\nCreates a new <code>ChainId</code> given a chain name and an epoch …\nBuilds a new connection identifier. Connection identifiers …\nReturns the static prefix to be used across all connection …\nSelects a version from the intersection of locally …\nHelper function to compare the state of this end with …\nExtract the version from this chain identifier.\nwith_version() checks if a chain_id is in the format …\nPer our convention, this event is generated on chain A.\nPer our convention, this event is generated on chain B.\nPer our convention, this event is generated on chain A.\nPer our convention, this event is generated on chain B.\nAn error while parsing an <code>Event</code>.\nMissing expected event attribute “{0}”\nError parsing client ID in “{key}”: {e}\nError parsing connection ID in “{key}”: {e}\nError parsing hex bytes in “{key}”: {e}\nUnexpected event attribute “{0}”\nWrong event type: expected {expected}\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnumeration of all possible messages that the ICS3 …\nPer our convention, this message is sent to chain A. The …\nPer our convention, this message is sent to chain B. The …\nPer our convention, this message is sent to chain A. The …\nPer our convention, this message is sent to chain B. The …\nClientId on chain A that the connection is being opened for\nClientId on B that the connection is being opened for\nClientState of client tracking chain A on chain B\nClientState of client tracking chain B on chain A\nConnectionId that chain A has chosen for it’s …\nConnectionId that chain B has chosen for it’s …\nConnectionId that chain B has chosen for it’s …\nheight of latest header of chain A that updated the client …\nheight of latest header of chain A that updated the client …\nClientId, ConnectionId and prefix of chain A\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOnly kept here for proper conversion to/from the raw type\nproof of ClientState tracking chain A on chain B\nproof that chain A has stored ClientState of chain B on …\nproof of ConnectionEnd stored on Chain A during …\nproof of ConnectionEnd stored on Chain A during …\nproof of ConnectionEnd stored on Chain B during ConnOpenTry\nproof that chain B has stored ConsensusState of chain A on …\nproof that chain A has stored ConsensusState of chain B on …\nHeight at which <code>proof_conn_end_on_a</code> in this message was …\nHeight at which all proofs in this message were taken\nHeight at which all proofs in this message were taken\nVersions supported by chain A")