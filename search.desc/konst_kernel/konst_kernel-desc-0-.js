searchState.loadedDescShard("konst_kernel", 0, "This crate has a few items reexported by <code>konst</code>, and used …\nGets the utf8-encoded char as a <code>&amp;[u8]</code>\nGets the utf8-encoded char as a <code>&amp;str</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMarker for user-defined types that can be converted into …\nMarker for const iterators\nMarker for non-standard library types.\nMarker for references.\nMarker for standard library types.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFor panicking with an error message.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe type parameter used for type witnesses.\nGets a type witness for <code>Self</code>.\nA constant with the type witness\nConstructs this type witness.\nConstructs a <code>TypeEq&lt;T, T&gt;</code>.\nValue-level proof that <code>L</code> is the same type as <code>R</code>\nGets the type argument that this type witness witnesses.\nA constant of the type witness\nSwaps the type parameters of this <code>TypeEq</code>\nReturns the argument unchanged.\nCombines <code>TypeEq&lt;L, R&gt;</code> and <code>TypeEq&lt;Usize&lt;UL&gt;, Usize&lt;UR&gt;&gt;</code> …\nConverts a <code>TypeEq&lt;L, R&gt;</code> to <code>TypeEq&lt;&amp;mut L, &amp;mut R&gt;</code>\nConverts a <code>TypeEq&lt;L, R&gt;</code> to <code>TypeEq&lt;&amp;L, &amp;R&gt;</code>\nCalls <code>U::from(self)</code>.\nJoins this <code>TypeEq&lt;L, R&gt;</code> with a <code>TypeEq&lt;R, O&gt;</code>, producing a …\nMaps the type arguments of this <code>TypeEq</code> by using the <code>F</code> …\nConstructs a <code>TypeEq&lt;T, T&gt;</code>.\nConstructs a <code>TypeEq&lt;L, R&gt;</code>.\nMaps the type arguments of this <code>TypeEq</code> by using the <code>F</code> …\nHints to the compiler that a <code>TypeEq&lt;L, R&gt;</code> can only be …\nConverts this <code>TypeEq</code> into a <code>TypeCmp</code>\nA no-op cast from <code>R</code> to <code>L</code>.\nA no-op cast from <code>L</code> to <code>R</code>.\nMaps the type arguments of this <code>TypeEq</code> by using the …\nMaps the type arguments of this <code>TypeEq</code> by using the …\nConstructs <code>TypeEq&lt;L, R&gt;</code> if <code>L == R</code>, otherwise returns None.\nCombines this <code>TypeEq&lt;L0, R0&gt;</code> with a <code>TypeEq&lt;L1, R1&gt;</code>, …\nCombines three <code>TypeEq&lt;L*, R*&gt;</code> to produce a …\nCombines four <code>TypeEq&lt;L*, R*&gt;</code> to produce a …")