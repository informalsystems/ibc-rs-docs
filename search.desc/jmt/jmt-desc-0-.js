searchState.loadedDescShard("jmt", 0, "This module implements <code>JellyfishMerkleTree</code> backed by …\nAn iterator over all key-value pairs in a …\nA Jellyfish Merkle tree data structure, parameterized by a …\nA hashed key used to index a <code>JellyfishMerkleTree</code>.\nAn error that occurs when the state root for a requested …\nAn owned value stored in the <code>JellyfishMerkleTree</code>.\nA root of a <code>JellyfishMerkleTree</code>.\nA <code>JellyfishMerkleTree</code> instantiated using the <code>sha2::Sha256</code> …\nA minimal trait representing a hash function. We implement …\nA trivial implementation of <code>SimpleHasher</code> that simply …\nSpecifies a particular version of the <code>JellyfishMerkleTree</code> …\nAppend value sets to the latest version of the tree, …\nThe batch version of <code>put_value_sets</code>.\nConsumes the hasher state to produce a digest.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the value (if applicable), without any proof.\nGets the proof that shows a list of keys up to …\nReturns the value (if applicable) and the corresponding …\nReturns the value corresponding to the specified key (if …\nReturns the value (if applicable) and the corresponding …\nReturns the digest of the provided data.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new hasher with default state.\nConstructs a new iterator. This puts the internal state in …\nCreates a <code>JellyfishMerkleTree</code> backed by the given …\nConstructs a new iterator. This puts the internal state in …\nMerkle proof types.\nThis is a convenient function that calls <code>put_value_sets</code> …\nThis is a convenient function that calls …\nReturns the new nodes and values in a batch after applying …\nSame as [<code>put_value_sets</code>], this method returns a Merkle …\nThis module implements the functionality to restore a …\nContains types used to bridge a <code>JellyfishMerkleTree</code> to the …\nIngests the provided data, updating the hasher’s state.\nHash the provided key with the provided hasher and return …\nA proof that can be used to authenticate an element in a …\nNote: this is not a range proof in the sense that a range …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the leaf node in this proof.\nIf <code>element_value</code> is present, verifies an element whose key …\nVerifies that the rightmost known leaf exists in the tree …\nVerifies an element whose key is <code>element_key</code> and value is …\nVerifies the proof is a valid non-inclusion proof that …\nVerifies an update of the [<code>JellyfishMerkleTree</code>], proving …\nImplements the functionality to restore a …\nThe interface used with <code>JellyfishMerkleRestore</code>, taken from …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDefines the ability for a tree to look up the preimage of …\nA wrapper of <code>InternalNode</code>.\nA wrapper of <code>LeafNode</code>.\nRepresents a key-value pair in the map.\nNibblePath defines a path in Merkle tree in the unit of …\nThe concrete node type of <code>JellyfishMerkleTree</code>.\nNode batch that will be written into db atomically with …\nThe unique key of each node.\nRepresents <code>null</code>.\nIndicates a node becomes stale since <code>stale_since_version</code>.\n<code>StaleNodeIndex</code> batch that will be written into db …\nDefines the interface between a <code>JellyfishMerkleTree</code> and …\nThis is a wrapper of <code>NodeBatch</code>, <code>StaleNodeIndexBatch</code> and …\nDefines the interface used to write a batch of updates …\nGet a bit iterator iterates over the whole nibble path.\nReset a NodeBatch to its empty state.\nExtend a node batch.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the i-th nibble.\nGets node given a node key. Returns error if the node does …\nGets node given a node key. Returns error if the node does …\nGet a node by key.\nGets node given a node key. Returns <code>None</code> if the node does …\nGets the rightmost leaf. Note that this assumes we are in …\nGets a value by identifier, returning the newest value …\nGets a value by identifier, returning the newest value …\nGets a value by identifier, returning the newest value …\nInsert a node into the batch.\nInsert a node into the batch.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the nibbles contains no elements.\nCheck if the node batch contains any items.\nGets the key hash.\nReturns the last nibble.\nMerge two NodeBatches into a single one.\nCreates a new <code>NodeKey</code>.\nCreates a new leaf node.\nCreates a new node batch\nGets the nibble path.\nGet a nibble iterator iterates over the whole nibble path.\nThe <code>NodeKey</code> identifying the node associated with this …\nReturns a reference to the current set of nodes.\nGet the total number of nibbles stored.\nGets the preimage of a key hash, if it is present in the …\nThe version since when the node is overwritten and becomes …\nReturns a reference to the current set of nodes.\nGets the version.\nWrites a node batch into storage.")