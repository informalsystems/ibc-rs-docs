searchState.loadedDescShard("namada_wallet", 0, "Provides functionality for managing keys and addresses for …\nA keypair with a block height after which it was created\nType alias for a spending key with a birthday.\nType alias for a viewing key with a birthday.\nWallet store decoding error\nA key derivation path\nAn encrypted keypair\nThe error that is produced when a given key cannot be …\nCould not decrypt a given key in the wallet\nCould not find a given key in the wallet\nErrors of wallet loading and storing\nWallet store file not found\nAn raw (unencrypted) keypair\nWallet store reading error\nSecure random number generator\nWallet store writing error\nExtended spending key with Borsh serialization compatible …\nA keypair stored in a wallet\nRepresents a collection of keys and addresses while …\nCaptures the interactive parts of the wallet’s …\nCaptures the permanent storage parts of the wallet’s …\nAdd validator data to the store\nAdd a vp_type to a given address\nWallet address and key aliases.\nA blockheight that precedes the creation of the keypair\nA blockheight that precedes the creation of the keypair\nA blockheight that precedes the creation of the keypair\nA default derivation path for shielded scheme\nA default derivation path for transparent scheme\nDerive a keypair from the given seed and path, derive an …\nDerive a masp shielded key from the given seed and path, …\nRestore a keypair from the user mnemonic code (read from …\nRestore a spending key from the user mnemonic code (read …\nExtend this wallet from another wallet (typically …\nExtend this wallet from pre-genesis validator wallet.\nFind the stored address by an alias.\nFind an alias by the address if it’s in the wallet.\nFind an alias by the payment address if it’s in the …\nFind the birthday of the given alias\nFind the stored key by a public key. If the key is …\nFind the stored key by a public key hash. If the key is …\nFind a derivation path by public key hash\nFind a derivation path by viewing key\nFind the payment address with the given alias in the …\nFind the public key by an alias or a public key hash.\nFind the public key by a public key hash. If the key is …\nFind a public key in the wallet from the given implicit …\nFind the stored key by an alias, a public key hash or a …\nFind the spending key with the given alias in the wallet …\nFind the viewing key with the given alias in the wallet …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to parse a derivation path from a string\nTry to parse a derivation path for transparent scheme from …\nImplementation of wallet functionality depending on a …\nGenerate a disposable signing key for fee payment and …\nGenerate a BIP39 mnemonic code, and derive HD wallet seed …\nGenerate a new secret key.\nGenerate a new keypair, derive an implicit address from …\nGenerate a spending key similarly to how it’s done for …\nGenerates a random mnemonic of the given mnemonic type.\nGet a raw keypair from a stored keypair. If the keypair is …\nGet all known addresses by their alias, paired with PKH, …\nGets all addresses given a vp_type\nGet all known payment addresses by their alias\nGet all known public keys by their alias.\nGet all known keys by their alias, paired with PKH, if …\nGet all known viewing keys by their alias\nReturns a reference to the validator data, if it exists.\nReturns a mut reference to the validator data, if it …\nGet all known viewing keys by their alias\nCheck if the path has a compatible shielded coin type\nCheck if the path has a compatible transparent coin type\nAdd a new address with the given alias. If the alias is …\nAdd a new keypair with the given alias. If the alias is …\nInsert a payment address into the wallet under the given …\nInsert a new public key with the given alias. If the alias …\nInsert a spending key into the wallet under the given alias\nInsert a viewing key into the wallet under the given alias\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the validator data, if it exists.\nCheck if the path is BIP-0044 conform …\nIndicates whether this key has been encrypted or not\nCheck if alias is an encrypted secret key\nCheck if alias is an encrypted spending key\nCheck if the path is compliant with Namada’s shielded …\nCheck if the path is compliant with Namada’s transparent …\nCheck if the path is SLIP-0010 conform …\nCheck if the path is ZIP-0032 conform …\nThe keypair itself\nThe keypair itself\nThe keypair itself\nLoad a wallet from the store file.\nLoad a wallet from the store file.\nTry to find an alias for a given address from the wallet. …\nTry to find an alias of the base token in the given IBC …\nMap the inner key type while maintaining the birthday.\nModified ZIP32 path is used to derive Ed25519 keys to …\nConstruct a keypair for storage. If no password is …\nCreate a new dated keypair. If no birthday is provided, …\nCreate a new wallet from the given backing store and …\nGet a reference to the path’s list of <code>ChildIndex</code> items\nProvides functionality for managing validator keys\nRead an alias from the file/env/stdin.\nRead mnemonic code from the file/env/stdin.\nRead a mnemonic code from the file/env/stdin.\nRead the password for decryption from the file/env/stdin.\nRemove keys and addresses associated with the given alias\nSave the wallet store to a file.\nSave the wallet store to a file.\nThe given alias has been selected but conflicts with …\nWallet Store information\nProvide immutable access to the backing store\nProvide mutable access to the backing store\nTake the validator data, if it exists.\nGet addresses with tokens VP type keyed and ordered by …\nAliases created from raw strings are kept in-memory as …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIs the underlying <code>String</code> empty?\nIf the alias is reserved for an internal address, return …\nReturns the length of the underlying <code>String</code>.\nNormalize an alias to lower-case\nDefault alias of a validator’s account address\nDefault alias of a validator’s consensus key\nDefault alias of a validator’s account key\nDefault alias of a validator’s Tendermint node key\nA trait for deriving WalletStorage for standard filesystems\nFor a non-interactive filesystem based wallet\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInitialize a wallet at the given directory\nThe directory in which the wallet is supposed to be stored\nFailed decoding the wallet store\nFailed to decode a key\nWays in which wallet store operations can fail\nFailed to read the wallet store\nFailed to write the wallet store\nValidator pre-genesis wallet store includes all the …\nValidator pre-genesis wallet includes all the required …\nCryptographic keypair for consensus key\nCryptographic keypair for consensus key\nDecode from TOML string bytes\nEncode in TOML string bytes\nCryptographic keypair for eth cold key\nCryptographic keypair for eth cold key\nCryptographic keypair for eth hot key\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a key and then encrypt it\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe wallet store that can be written/read to/from TOML\nCryptographic keypair for Tendermint node key\nCryptographic keypair for Tendermint node key\nSpecial validator keys. Contains the ETH hot key.\nGrouping of addresses by validity predicate.\nActions that can be taken when there is an alias conflict\nReplace the existing alias\nReselect the alias that is ascribed to a given entity\nSkip assigning the given entity an alias\nA Storage area for keys and addresses\nThe Token\nSpecial data associated with a validator\nSpecial keys for a validator\nAdd validator data to the store\nAdds a VP type to the address\nThe address associated to a validator\nCheck if any map of the wallet contains the given alias\nDecode a Store from the given bytes\nGenerate a new secret key from the seed.\nGenerate a new spending key from the seed.\nEncode a store into a string of bytes\nSpecial hot keypair for signing Ethereum bridge txs\nExtend this store from another store (typically …\nExtend this store from pre-genesis validator wallet.\nFind the stored address by an alias.\nFind an alias by the address if it’s in the wallet.\nFind an alias by the address if it’s in the wallet.\nFind the stored alias for a public key hash.\nFind the birthday of the given alias\nFind the stored key by a public key.\nFind the stored key by a public key hash.\nFind a derivation path by public key hash\nFind a derivation path by viewing key\nFind the payment address with the given alias and return it\nFind the stored key by an alias, a public key hash or a …\nFind the public key by a public key hash.\nFind the stored key by an alias, a public key hash or a …\nFind the spending key with the given alias and return it\nFind the viewing key with the given alias and return it\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet all known addresses by their alias.\nget an address with the vp type\nGet all known payment addresses by their alias.\nGet the protocol keypair\nGet all known public keys by their alias.\nGet all known keys by their alias, paired with PKH, if …\nGet all known spending keys by their alias.\nReturns a reference to the validator data, if it exists.\nReturns a mut reference to the validator data, if it …\nGet all known viewing keys by their alias.\nInsert a new address with the given alias. If the alias is …\nInsert a new secret key with the given alias. If the alias …\nInsert payment addresses similarly to how it’s done for …\nInsert public keys\nInsert spending keys similarly to how it’s done for …\nInsert viewing keys similarly to how it’s done for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the validator data, if it exists.\nspecial keys for a validator\nSpecial keypair for signing protocol txs\nCompletely remove the given alias from all maps in the …\nTake the validator data, if it exists.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")