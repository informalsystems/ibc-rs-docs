searchState.loadedDescShard("namada_storage", 0, "This crate provides\nA segment made of an address\nBlock\nBlock column family name\nHash of a block as fixed-size byte array\nThe block header data from Tendermint header relevant for …\nHeight of a block, i.e. the level. The <code>default</code> is the …\nRepresents the indices of the accepted transactions in a …\nThe block’s state as stored in the database.\nThe block’s state to write into the database.\nA DB’s cache\nA custom error\nA database backend.\nA database prefix iterator.\nAtomic batch write.\nDiffs\nDiffs column family name\nStorage column families\nA storage key segment\nA type that can apply a key-value change to a DB\nA result of a function that may fail\nThe length of the epoch type\nEpoch identifier. Epochs are identified by consecutive …\nPredecessor block epochs\nContains the error value\nContains the error value\nContains the error value\nContainer of all Ethereum event queues.\nDraining iterator over a queue of Ethereum events,\nA hash, typically a sha-2 hash of a tx\nThe maximum size of an IBC key (in bytes) allowed in …\nA queue of confirmed Ethereum events of type <code>E</code>.\nThe separator of storage key segments\nA storage key is made of storage key segments <code>DbKeySeg</code>, …\nA <code>Key</code> made of borrowed key segments <code>DbKeySeg</code>.\nRepresents a segment in a path that may be used as a …\nA type that can apply a key-value change to DB.\nContains the success value\nContains the success value\nContains the success value\nAn extension to <code>Option</code> to allow turning <code>None</code> case to an …\nPattern iterator\nPrefix iterator\nStorage read prefix iterator\nA value of a storage prefix iterator.\nReplay protection\nReplay protection column family name\nThe reserved storage key prefix for addresses\nThe reserved storage key for validity predicates\nDiffs for rollback (only kept for 1 block)\nDiffs for rollback (only kept for 1 block) column family …\nSource data to restore a database.\nA result of a function that may fail\nResult of a storage API call.\nResult extension to easily wrap custom errors into <code>Error</code>.\nState\nState column family name\nSubspace\nSubspace column family name\nThe storage hasher used for the merkle tree.\nCommon storage read interface\nCommon storage write interface\nStorage keys that are utf8 encoded strings\nAny other key segment\nThe length of the transaction index\nA wrapper around raw bytes to be stored as values in a …\nTransaction index within block.\nThe reserved storage key prefix for validity predicates\nThe reserved storage key prefix for wasm codes’ length\nThe reserved storage key prefix for wasm codes’ name\nThe reserved storage key prefix for wasm codes\nThe reserved storage key prefix for wasm code hashes\nThe reserved storage key prefix for wasm codes\nA handle for batch writes\nAccept the tx at the given position.\nWrite block’s metadata. Merkle tree sub-stores are …\nEstablished address generator\nEstablished address generator\nReturn an array of all column families\nApply a series of key-value changes to the DB.\nApply a series of key-value changes to the DB.\nReturn the inner pointer to the hash data.\nStart write batch.\nBatch delete the value with the given height and account …\nBatch write the value with the given height and account …\nChecked index addition.\nChecked epoch addition.\nChecked block height addition.\nChecked epoch division.\nChecked epoch multiplication.\nChecked epoch integral reminder.\nChecked epoch subtraction. Computes self - rhs, returning …\nChecked block height subtraction.\nLazy data structures for storage access where elements are …\nStructure holding data that needs to be added to the …\nStructure holding data that needs to be added to the …\nGiven hashes A and B, compute Sha256(A||B), but if one …\nShielded tokens conversion state\nThe conversion state\nThe conversion state\nDelete a value at the given key from storage.\nDelete all key-vals with a matching prefix.\nDelete the value with the given height and account …\nAttempt to downgrade the inner error to <code>E</code> if any.\nReturns some reference to the inner value if it is of type …\nThe number of bytes when this header is encoded\nEpoch of the block\nEpoch of the block\nCheck if <code>KeyRef</code> is equal to a <code>Key</code>.\nThe queue of Ethereum events to be processed in order.\nThe queue of Ethereum events to be processed in order.\nThe latest block height on Ethereum processed, if the …\nThe latest block height on Ethereum processed, if the …\nExecute write batch.\nReturns the addresses from the key segments\nReturns the first segment of the key, or <code>None</code> if it is …\nThe first block height 1.\nReturn all starting block heights for each successive …\nThe block heights of the first block of each known epoch. …\nFlush data on the memory to persistent them\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the address from the first key segment if it’s …\nReturn the segment at the index parameter\nGetting the block epoch. The epoch is that of the block to …\nGetting the block header.\nGetting the block height. The height is that of the block …\nGetting the chain ID.\nGet the height of the first block of the current epoch.\nLook up the epoch of a given block height. If the given …\nGiven the epoch at the given block height.\nGet the height of the first block of the given epoch.\nLook up the starting block height of an epoch at or before …\nGet the native token address\nGiven the information about predecessor block epochs\nLook up the starting block height of the given epoch\nGet the transaction index.\nStorage <code>has_key</code> in. It will try to read from the storage.\nCheck if the given replay protection entry exists\nHash the value to store\nMerkle root hash of block\nHeader of the block\nHeight of the block\nHeight of the block\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert a <code>std::result::Result</code> into storage_api <code>Result</code>.\nCheck if the tx at the given position is accepted.\nReturns <code>true</code> if the key is empty\nCheck if the given key is a key to a validity predicate. …\nCheck if the hash is all zeros\nCheck if an instance is the zero value\nIterates over all addresses in the key segments\nIterate a range of epochs, inclusive of the start and end.\nRead replay protection storage from the current bucket\nRead subspace new diffs at a given height\nStorage prefix iterator. It will try to read from the …\nRead subspace old diffs at a given height\nWARNING: This only works for values that have been …\nIterate Borsh encoded items matching the given prefix, …\nWARNING: This only works for values that have been …\nStorage prefix iterator ordered by the storage keys. It …\nIterate items matching the given prefix, ordered by the …\nIterate Borsh encoded items matching the given prefix and …\nIterate a range of consecutive epochs starting from <code>self</code> …\nReturn an iterator over the removed txs in this …\nRead results subspace key value pairs from the DB\nReturns a new key with segments of <code>Self</code> and the given key\nStorage key\nReturns the last segment of the key, or <code>None</code> if it is …\nReturn the length of the hash.\nReturns the length\nThe length of the input (without the padding)\nMerkle tree stores\nDB mock for testing\nMove the current replay protection bucket to the general …\nConvert from a <code>usize</code> or panic.\nCreate an <code>Error</code> from another <code>std::error::Error</code>.\nCreate an <code>Error</code> from a heap allocated message.\nReturn an Ethereum events queue starting at the specified …\nCreate an <code>Error</code> from a static message.\nRecord start of a new epoch at the given block height\nChange to the next epoch\nMinimum block height at which the next epoch may start\nMinimum block height at which the next epoch may start\nMinimum block time at which the next epoch may start\nMinimum block time at which the next epoch may start\nGet the height of the next block\nHash of the addresses of the next validator set\nTransforms the <code>Option&lt;T&gt;</code> into a <code>Result&lt;T&gt;</code>, mapping [<code>Some(v)</code>…\nOpen the database from provided path\nThe original key string, in bytes\nOverwrite a new value in storage, taking into account …\nReverse of <code>into_string</code>. Convert key segment to <code>Self</code>.\nParses string and returns a key\nReturns a key from the given DB key path that has the …\nGet the path to the db in the filesystem, if it exists …\nGet the path to the db in the filesystem, if it exists …\nPredecessor block epochs\nPredecessor block epochs\nChange to the previous epoch.\nGet the height of the previous block\nPrune Merkle tree stores at the given epoch\nPrune non-persisted diffs that are only kept for one block …\nReturns a new key with segments of <code>Self</code> and the given …\nPush a new Ethereum event of type <code>E</code> into the queue, and …\nConvert <code>Self</code> to a string.\nStorage read Borsh encoded value. It will try to read from …\nRead the block header with the given height from the DB\nRead the signed nonce of Bridge Pool\nStorage read raw bytes. It will try to read from the …\nRead the value for the account diffs at the corresponding …\nRead the last committed block’s metadata\nRead the merkle tree stores with the given epoch. If a …\nRead the latest value for account subspace key from the DB\nRead the value for account subspace key at the given …\nReject the tx at the given position.\nOverwrite the contents of the current database with the …\nResults of applying transactions\nResults of applying transactions\nChecked epoch subtraction. Computes self - rhs, returning …\nThe segments of the key in the original (left-to-right) …\nReference of key segments\nA sentinel value block height 0 may be used before any …\nCompute sha256 of some bytes\nReturns the prefix before the last segment and last …\nReturns the prefix before the last segment and last …\nCheck if the key begins with the given prefix and returns:\nReturns a sub key without the first segment\nTime of the block\nTime of the block\nTimestamp associated to block\nConvert <code>Self</code> to a key segment. This mapping should …\nGet the name of the column family\nConvert this <code>Hash</code> to a <code>Vec</code>.\nQueue of transfer to Namada events.\nThe utf8 bytes representation of the key to be used …\nTransaction queue\nThe key and values that may be persisted in a DB.\nUnchecked epoch addition.\nUpdate epoch delay\nUpdate epoch delay\nReturns a key of the validity predicate of the given …\nRaw value bytes\nReturns a key of the wasm code of the given hash\nReturns a key of the wasm code’s length of the given hash\nReturns a key of wasm code’s hash of the given name\nReturns a key of the wasm code hash of the given code path\nTakes ownership of the key, appends a new segment to it, …\nWrap another <code>std::error::Error</code> with a static message.\nAdd a static message to a possible error in <code>Result</code>.\nWrite a value to be encoded with Borsh at the given key to …\nWrite a value as bytes at the given key to storage.\nWrite a replay protection entry\nWrite the value with the given height and account subspace …\nReturn zeros\nThe value indicating that a leaf should be deleted\nA lazy collection of storage values.\nLazy collection with a nested lazy collection\nSimple lazy collection with borsh deserializable elements\nPossible sub-keys in the collection\nA type of a value in the inner-most collection\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the given storage key is a valid data key.\nCheck if the given storage key is a valid LazyVec sub-key …\nLazy map.\nLazy set.\nLazy dynamically-sized vector.\nCreate or use an existing vector with the given storage <code>key</code>…\nTrait used to facilitate collection of lazy maps into …\nThe type of the value of the lazy map\nSubkey corresponding to the data elements of the LazyMap\nData sub-key, further sub-keyed by its literal map key\nData sub-key\nLazy map.\nA <code>LazyMap</code> with another <code>LazyCollection</code> inside it’s value <code>V</code>\nPossible sub-keys of a nested <code>LazyMap</code>\nPossible sub-keys of a <code>LazyMap</code>\nGet a nested collection at given key <code>key</code>. If there is no …\nCollect the lazy map into an eager map\nReturns whether the map contains a key with a value.\nReturns whether the nested map contains a certain key with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the value corresponding to the key, if any.\nGet the sub-key of a given element\nInserts a key-value pair into the map.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the map contains no elements.\nReturns whether the map contains no elements.\nAn iterator visiting all key-value elements. The iterator …\nAn iterator visiting all key-value elements, where the …\nReads the number of elements in the map.\nCreate or use an existing map with the given storage <code>key</code>.\nRemoves a key from the map if it’s present, returning …\nRemove all map entries at a given key prefix\nTry update a value at the given key with the given …\nUpdate a value at the given key with the given function. …\nLiteral map key\nSub-key in the nested collection\nLiteral set key\nA lazy set.\nPossible sub-keys of a <code>LazySet</code>\nReturns whether the set contains a value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the storage sub-key of a given raw key\nInserts a key into the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the set contains no elements.\nAn iterator visiting all keys. The iterator element type …\nReads the number of elements in the map.\nCreate or use an existing map with the given storage <code>key</code>.\nRemoves a key from the set if it’s present, returning …\nTries to inserts a key into the set.\nSubkey corresponding to the data elements of the LazyVec\nData sub-key, further sub-keyed by its index\nUsing <code>u64</code> for vector’s indices\nSubkey pointing to the length of the LazyVec\nLazy dynamically-sized vector.\nLength sub-key\nPossible sub-keys of a <code>LazyVec</code>\nRead the last element\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRead the first element\nRead an element at the index or <code>Ok(None)</code> if out of bounds.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the vector contains no elements.\nCheck if the given storage key is a valid LazyVec sub-key …\nAn iterator visiting all elements. The iterator element …\nReads the number of elements in the vector.\nCreate or use an existing vector with the given storage <code>key</code>…\nRemoves the last element from a vector and returns it, or …\nAppends an element to the back of a collection.\nUpdate an element at the given index.\nAn account’s address\nA representation of a leaf in the conversion tree\nA representation of the conversion state\nGiven a number represented as <code>M*B^D</code>, then <code>M</code> is the …\nAn established address is generated on-chain\nAn immutable commitment tree\nAn implicit address is derived from a cryptographic key\nAn internal address represents a module with a native VP\nThe four possible u64 words in a <code>Uint</code>. Used for converting …\nWrapper type around <code>Epoch</code> for type safe operations …\nAble to borrow conversion state.\nA node within the Sapling commitment tree.\nAble to borrow mutable conversion state.\nProduces an asset generator without cofactor cleared\nMap assets to their latest conversion and position in …\nReturns a blank leaf node.\nComputes the note commitment\nReturns the parent node within the tree of the two given …\nReturns [<code>self.cmu</code>] in the correct representation for …\nThe actual conversion and generator\nBorrow immutable conversion state\nBorrow mutable conversion state\nDecode an address from Bech32m encoding\nThe denomination associated with the above toke\nGet the corresponding u64 word from the input uint256.\nThis deserialization is unsafe because it does not do the …\nThe digit position covered by this asset type\nReturns the empty root for the given depth.\nEncode an address with Bech32m encoding\nThe masp epoch of the asset type\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nProduces an asset generator without cofactor cleared\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempt to construct an asset type from an existing asset …\nConstructs a new note commitment tree node from a …\nReturn the identifier of this asset type\nGet the asset identifier as a vector of bools\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf the address established?\nIf the address implicit?\nIf the address internal?\nIterator over the possible denominations\nThe position of this leaf in the conversion tree\nMerge the n-1 full Merkle trees with the last possibly …\nCreate a new AsstType from a unique asset name Not …\nConstruct a commitment tree with the given leaf nodes\nAttempt to create a new AssetType from a unique asset name …\nChange to the next masp epoch.\nThe last amount of the native token distributed\nConstruct a merkle path to the given position in …\nChange to the previous masp epoch.\nTry to get a raw hash of an address, only defined for …\nDeserialize an AssetType object\nParses a node from the given byte source.\nGet the root node of the commitment tree\nReturns the number of leaf nodes in the tree.\nPrint the type of the address and its bech32m encoded value\nThe token associated with this asset type\nThe tree currently containing all the conversions\nConverts and <code>Epoch</code> into a <code>MaspEpoch</code> based on the provided …\nConstruct a value commitment from given value and …\nComputes the value commitment for a given amount and …\nProduces a value commitment generator with cofactor cleared\nSerializes this node.\nReturns a 0 masp epoch\nAn in-memory DB for testing.\nSource to restore a <code>MockDB</code> from.\nAn in-memory write batch is not needed as it just updates …\nA prefix iterator base for the <code>MockPrefixIterator</code>.\nMockDB pattern iterator\nA prefix iterator for the <code>MockDB</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe concrete iterator implementation\nThe concrete iterator\nReturns the next pair and the gas cost\nThe prefix that is being iterated. This prefix will be …\nAn Ethereum event to be processed by the Namada ledger\nBroadcast the given Ethereum event.\nExpired transaction kinds.\nQueue of expired transactions that need to be …\nA confirmation event that a batch of transfers have been …\nEvent transferring batches of ether or Ethereum based …\nEvent indication that the validator set has been updated …\nConsume all the transactions in the queue.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSHA256 of the Borsh serialization of the <code>EthereumEvent</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPush a new transaction to the back of the queue.\nHash of the validators in the bridge contract\nHash of the validators in the governance contract\nMonotonically increasing nonce\nMonotonically increasing nonce\nMonotonically increasing nonce\nThe Namada address that receives the gas fees for relaying …\nThe batch of transfers\nThe batch of transfers\nStructure holding data that will be committed to the …\nA key-value pair as raw bytes\nStorage prefix iterator generic wrapper type.\nStorage prefix iterator generic wrapper type.\nA compiled regular expression for searching Unicode …\nReturns the original string of this regex.\nReturns a fresh allocated set of capture locations that can\nReturns an iterator over the capture names in this regex.\nThis routine searches for the first match of this regex in …\nReturns the same as <code>Regex::captures</code>, but starts the search …\nReturns an iterator that yields successive non-overlapping …\nReturns the number of captures groups in this regex.\nThis is like <code>Regex::captures</code>, but writes the byte offsets …\nReturns the same as <code>Regex::captures_read</code>, but starts the …\nThis routine searches for the first match of this regex in …\nReturns the same as <code>Regex::find</code>, but starts the search at …\nReturns an iterator that yields successive non-overlapping …\nShows the original regular expression.\nShows the original regular expression.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to parse a string into a regular expression\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if there is a match for the regex …\nReturns the same as <code>Regex::is_match</code>, but starts the search …\nThe concrete iterator implementation\nThe concrete iterator implementation\nInitialize a new prefix iterator\nInitialize a new prefix iterator\nCompiles a regular expression. Once compiled, it can be …\nReturns the next pair and the gas cost\nThe pattern we are matching keys against.\nReplaces the leftmost-first match in the given haystack …\nReplaces all non-overlapping matches in the haystack with …\nReplaces at most <code>limit</code> non-overlapping matches in the …\nSerialize to bytes\nReturns the end byte offset of the first match in the …\nReturns the same as <code>Regex::shortest_match</code>, but starts the …\nReturns an iterator of substrings of the haystack given, …\nReturns an iterator of at most <code>limit</code> substrings of the …\nReturns the total number of capturing groups that appear …\nThe prefix that is being iterated. This prefix will be …\nAttempts to parse a string into a regular expression\nAttempts to parse a string into a regular expression\nMap from tx hashes to their gas cost")