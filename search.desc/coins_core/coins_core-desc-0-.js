searchState.loadedDescShard("coins_core", 0, "<code>coins-core</code> is an abstract description of UTXO …\nContains simplified access to <code>bech32</code> and <code>base58check</code> …\nHolds utilites for working with cryptographic digests, and …\nImplement <code>serde::Serialize</code> and <code>serde::Deserialize</code> by …\nImplement conversion between script types by passing via …\nUseful macros for implementing new chains\nInstantiate a new marked digest. Wraps the output of some …\nRe-exports of common types.\nA simple trait for binary (de)Serialization using std <code>Read</code> …\nWrap a prefixed vector of bytes (<code>u8</code>) in a newtype, and …\nBubbled up error from bech32 library\nBubbled up error from base58check library\nBubbled up error from base58check library\nErrors that can be returned by the Bitcoin <code>AddressEncoder</code>.\nA simple result type alias\nContains the error value\nInvalid Address Size\nOp Return ScriptPubkey was passed to encoder\nContains the success value\nInvalid Segwit Version\nReturned when ScriptPubkey type is unknown. May be …\nBech32 HRP does not match the current network.\nBase58Check version does not match the current network\nDecodes base58check into a byte string. Returns a …\nDecode a witness program from a bech32 string. Caller …\nEncodes a byte slice to base58check with the specified …\nEncode a byte vector to bech32. This function expects <code>v</code> to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe expected HRP.\nThe expected version byte.\nThe actual HRP.\nThe actual version byte.\nConvenience wrapper trait covering functionality of …\nOutput of a Digest function\nStruct representing a generic array - <code>GenericArray&lt;T, N&gt;</code> …\nA <code>Digest</code> implementation that performs Bitcoin style …\nA bitcoin-style Hash160\nA <code>Digest</code> implementation that performs Bitcoin style …\nA bitcoin-style Hash256\nA marked digest\nConvenience interface for hash function outputs, …\nRIPEMD-160 hasher.\nSHA-256 hasher.\nSHA-3-256 hasher state.\nUse as a mutable slice\nExtracts a mutable slice containing the entire array.\nUse as a slice\nExtracts a slice containing the entire array.\nProcess input data in a chained manner.\nConstruct a <code>GenericArray</code> from a slice by cloning its …\nCompute hash of <code>data</code>.\nShortcut to produce a marked digest\nRetrieve result and consume hasher instance.\nWrite result into provided array and consume the hasher …\nWrite result into provided array and reset the hasher …\nProduce a marked digest from the hasher\nRetrieve result and reset hasher instance.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts mutable slice to a mutable generic array reference\nConverts slice to a generic array reference with inferred …\nDeserialize to BE hex\nCreates a new <code>GenericArray</code> instance from an iterator with …\nConverts mutable slice to a mutable generic array reference\nConverts slice to a generic array reference with inferred …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new hasher instance.\nCreate new hasher instance which has processed the …\nGet output size of the hasher\nReset hasher instance to its initial state.\nReturn a clone in opposite byte order\nReturns the number of bytes in the digest\nConvert to BE hex\nUnwrap the marked digest, returning the underlying …\nUnwrap the marked digest, returning the underlying …\nProcess data, updating the internal state.\nConvenience wrapper trait covering functionality of …\nProcess input data in a chained manner.\nCompute hash of <code>data</code>.\nRetrieve result and consume hasher instance.\nWrite result into provided array and consume the hasher …\nWrite result into provided array and reset the hasher …\nRetrieve result and reset hasher instance.\nCreate new hasher instance.\nCreate new hasher instance which has processed the …\nGet output size of the hasher\nReset hasher instance to its initial state.\nProcess data, updating the internal state.\nSpecify <code>AtMost</code> to stop deserializing at a specific number.\nA simple trait for deserializing from <code>std::io::Read</code> and …\nAn error by a component call in data structure …\n<code>deserialize_base64</code> encountered an error on its input.\nContains the error value\nAn associated error type\nSpecify <code>Exactly</code> to deserialize an exact number, or return …\n<code>deserialize_hex</code> encountered an error on its input.\nThrown when <code>ReadSeqMode::Exactly</code> reads fewer items than …\nIoError bubbled up from a <code>Write</code> passed to a …\nVarInts must be minimal.\nContains the success value\nOperation mode for <code>read_seq_from</code>.\nErros related to serialization of types.\nType alias for serialization errors\nSpecify <code>UntilEnd</code> to read to the end of the reader.\nSerialize <code>self</code> to a base64 string, using standard RFC4648 …\nDecodes a hex string to a <code>Vec&lt;u8&gt;</code>, deserializes an …\nMatches the length of the VarInt to the 1-byte flag\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalculates the minimum prefix length for a VarInt encoding …\nMatches the VarInt prefix flag to the serialized length\nConvenience function for reading a Bitcoin-style VarInt\nDeserializes an instance of <code>Self</code> from a <code>std::io::Read</code>. The …\nConvenience function for reading a prefixed vector\nRead a sequence of objects from the reader. The mode …\nConvenience function for reading a LE u32\nConvenience function for reading a LE u64\nSerialize <code>self</code> to a base64 string, using standard RFC4648 …\nSerializes <code>self</code> to a vector, returns the hex-encoded vector\nReturns the byte-length of the serialized data structure.\nConvenience function for writing a Bitcoin-style VarInt\nConvenience function to write a Bitcoin-style …\nWrite a sequence of <code>ByteFormat</code> objects to a writer. The …\nSerializes <code>self</code> to a <code>std::io::Write</code>. Following <code>Write</code> trait …\nConvenience function for writing a LE u32\nConvenience function for writing a LE u64\nThe number of items expected\nThe number of items succesfully deserialized")