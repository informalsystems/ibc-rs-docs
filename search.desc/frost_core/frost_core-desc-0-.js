searchState.loadedDescShard("frost_core", 0, "FROST (Flexible Round-Optimised Schnorr Threshold …\nA type refinement for the scalar field element …\nA FROST ciphersuite specifies the underlying prime-order …\nThe ciphersuite does not support DKG.\nError deserializing value.\nThis identifier is duplicated.\nDuplicated shares provided\nAn element of the <code>Ciphersuite</code> <code>C</code>’s <code>Group</code>.\nAn element of our group that we will be computing over.\nAn error related to FROST.\nA prime order finite field GF(q) over which all scalar …\nA prime order finite field GF(q) over which all scalar …\nAn error related to a scalar Field.\nError in scalar Field.\nA prime-order group (or subgroup) that provides everything …\nThe prime order group (or subgroup) that this ciphersuite …\nAn error related to a Group (usually an elliptic curve or …\nError in elliptic curve Group.\nH1 for a FROST ciphersuite.\nH2 for a FROST ciphersuite.\nH3 for a FROST ciphersuite.\nH4 for a FROST ciphersuite.\nH5 for a FROST ciphersuite.\nHash function for a FROST ciphersuite, used for the DKG.\nHash function for a FROST ciphersuite, used for deriving …\nA unique byte array of fixed length.\nThe ciphersuite ID string\nThe ciphersuite does not support deriving identifiers from …\nCommitment equals the identity\nThe participant’s commitment is incorrect\nIncorrect number of commitments.\nIncorrect number of identifiers.\nIncorrect number of packages.\nIncorrect number of shares.\nThe incorrect package was specified.\nError in coefficient commitment deserialization.\nmax_signers is invalid\nThis element MUST NOT be the identity.\nmax_signers is invalid\nmin_signers is invalid\nThis element MUST have (large) prime order.\nThe proof of knowledge is not valid.\nSecret share verification failed.\nSignature verification failed.\nSignature share verification failed.\nThis scalar MUST NOT be zero.\nThe encoding of a group element was malformed.\nThis identifier is unserializable.\nThe encoding of a group scalar was malformed.\nThe encoding of a signature was malformed.\nThe encoding of a signing key was malformed.\nThe encoding of a verifying key was malformed.\nThe participant’s commitment is missing from the Signing …\nRound 1 package not found for Round 2 participant.\nAn element of the <code>Ciphersuite</code> <code>C</code>’s <code>Group</code>’s scalar <code>Field</code>.\nAn element of the scalar field GF(p). The Eq/PartialEq …\nHelper struct to serialize a Scalar.\nA unique byte array buf of fixed length N.\nA unique byte array buf of fixed length N.\nError serializing value.\nA Schnorr signature over some prime order group (or …\nA unique byte array of fixed length that is the …\nA signing key for a Schnorr signature on a FROST …\nThis identifier does not belong to a participant in the …\nA valid verifying key for Schnorr signatures over a FROST …\nPerforms batch Schnorr signature verification.\nGenerates the challenge as is required for Schnorr …\nThe order of the the quotient group when the prime order …\nReturn the identifier of the participant that caused the …\nA member function of a <code>Field</code> that attempts to map a byte …\nA member function of a <code>Group</code> that attempts to map a byte …\nConverts bytes as <code>Ciphersuite::SignatureSerialization</code> into …\nDeserialize from bytes\nDeserialize from bytes\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a SigningKey from a scalar.\nCreates a challenge from a scalar.\nAn implementation of FROST (Flexible Round-Optimized …\nThe fixed generator element of the prime order group.\nAdditive identity of the prime order group.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes the multiplicative inverse of an element of the …\nA member function of a <code>Field</code> that maps a <code>Scalar</code> to a …\nCreate a new Signature.\nGenerate a new signing key.\nCreate a new VerifyingKey from the given element.\nReturns the one element of the field, the multiplicative …\nGenerate a random scalar from the entire space [0, l-1]\nA member function of a <code>Field</code> that maps a <code>Scalar</code> to a …\nA member function of a group <em>G</em> that maps an <code>Element</code> to a …\nConverts this signature to its …\nSerialize <code>SigningKey</code> to bytes\nSerialize <code>VerifyingKey</code> to bytes\nCreate a signature <code>msg</code> using this <code>SigningKey</code>.\nReturn the underlying element.\nReturn the underlying scalar.\nReturn the underlying scalar.\nVerify a purported <code>signature</code> over <code>msg</code> made by this …\nVerify a signature for this ciphersuite. The default …\nReturns the zero element of the field, the additive …\nThe identifier of the signer whose share validation failed.\nThe identifier of the signer whose share validation failed.\nA batch verification item.\nA batch verification context.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a new batch verifier.\nQueues an Item for verification.\nPerforms batch verification, returning <code>Ok(())</code> if all …\nPerform non-batched verification of this <code>Item</code>.\nThe binding factor, also known as <em>rho</em> (ρ)\nA list of binding factors and their associated identifiers.\nThe product of all signers’ individual commitments, …\nA FROST participant identifier.\nGenerated by the coordinator of the signing operation and …\nAggregates the signature shares to produce a final …\nCompute the preimages to H1 to compute the per-signer …\n<code>compute_binding_factors</code> in the spec\nGenerates the group commitment which is published as part …\nGenerates a lagrange coefficient.\nDerive an Identifier from an arbitrary byte string.\nGenerates the lagrange coefficient for the i’th …\nDeserialize an Identifier from a serialized buffer. …\nDeserializes <code>BindingFactor</code> from bytes.\nDeserialize the struct from a slice of bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the <code>BindingFactor</code> for the given identifier, or None if …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn iterator through all factors.\nFROST keys, keygen, key shares\nMessage which each participant will sign.\nCreate a new <code>BindingFactorList</code> from a map of identifiers …\nCreate a new <code>SigningPackage</code>\nFROST Round 1 functionality and types\nFROST Round 2 functionality and types, for signature share …\nSerialize the identifier using the ciphersuite encoding.\nSerializes <code>BindingFactor</code> to bytes.\nSerialize the struct into a Vec.\nGet a signing commitment by its participant identifier, or …\nThe set of commitments participants published in the first …\nReturn the underlying element.\nA <code>Group::Element</code> newtype that is a commitment to one …\nA user-provided list of identifiers.\nUse the default values (1 to max_signers, inclusive).\nThe identifier list to use when generating key shares.\nA FROST keypair, which can be generated either by a …\nPublic data that contains all the signers’ verifying …\nA secret share generated by performing a (t-out-of-n) …\nA secret scalar value representing a signer’s share of …\nContains the commitments to the coefficients for our …\nA public group element that represents a single signer’s …\nThe commitments to be distributed among signers.\nDeserialize from bytes\nDeserialize from bytes\nCreates a new commitment from a coefficient input\nReturns VerifiableSecretSharingCommitment from a vector of …\nDeserialize the struct from a slice of bytes.\nDeserialize the struct from a slice of bytes.\nDeserialize the struct from a slice of bytes.\nDistributed Key Generation functions and structures.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAllows all participants’ keys to be generated using a …\nThe public verifying key that represents the entire group.\nThe joint public key for the entire group.\nThe participant identifier of this <code>SecretShare</code>.\nDenotes the participant identifier each secret share key …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet field <code>min_signers</code> from instance of <code>KeyPackage</code>.\nCreate a new <code>SigningShare</code> from a scalar.\nCreate a new <code>VerifyingShare</code> from a element.\nCreate a new <code>SecretShare</code> instance.\nCreate a new <code>KeyPackage</code> instance.\nCreate a new <code>PublicKeyPackage</code> instance.\nThis participant’s public key.\nRecompute the secret from at least <code>min_signers</code> secret …\nRepairable Threshold Scheme\nGets the inner <code>SigningShare</code> value.\nThis participant’s secret share.\nSerialize to bytes\nSerialize to bytes\nreturns serialized element\nReturns serialized coefficent commitments\nSerialize the struct into a Vec.\nSerialize the struct into a Vec.\nSerialize the struct into a Vec.\nThe verifying shares for all participants. Used to …\nSplits an existing key into FROST shares.\nGet the inner element.\nGet the inner scalar.\nTries to verify a share and construct a <code>KeyPackage</code> from it.\nReturns inner element value\nSecret Key.\nVerifies that a secret share is consistent with a …\nPerforms the first part of the distributed key generation …\nPerforms the second part of the distributed key generation …\nPerforms the third and final part of the distributed key …\nDKG Round 1 structures.\nDKG Round 2 structures.\nThe package that must be broadcast by each participant to …\nThe secret package that must be kept in memory by the …\nThe public commitment from the participant (C_i)\nDeserialize the struct from a slice of bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>Package</code> instance.\nThe proof of knowledge of the temporary secret (σ_i = …\nSerialize the struct into a Vec.\nA package that must be sent by each participant to some …\nThe secret package that must be kept in memory by the …\nDeserialize the struct from a slice of bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>Package</code> instance.\nThe secret share being sent.\nSerialize the struct into a Vec.\nStep 1 of RTS.\nCommunication round\nCommunication round\nOne signer’s share of the group commitment, derived from …\nA scalar that is a signing nonce.\nA group element that is a commitment to a signing nonce …\nPublished by each participant in the first round of the …\nComprised of hiding and binding nonces.\nGets the binding <code>Nonce</code>\nCommitment to the binding <code>Nonce</code>.\nPerformed once by each participant selected for the …\nDeserialize <code>Nonce</code> from bytes\nDeserialize <code>NonceCommitment</code> from bytes\nDeserialize the struct from a slice of bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the hiding <code>Nonce</code>\nCommitment to the hiding <code>Nonce</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerates a new uniformly random signing nonce by sourcing …\nGenerates a new signing nonce.\nCreate new SigningCommitments\nDone once by each participant, to generate <em>their</em> nonces …\nSerialize <code>Nonce</code> to bytes\nSerialize <code>NonceCommitment</code> to bytes\nSerialize the struct into a Vec.\nComputes the signature commitment share from these round …\nA participant’s signature share, which the coordinator …\nCompute the signature share for a signing operation.\nDeserialize <code>SignatureShare</code> from bytes\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSerialize <code>SignatureShare</code> to bytes\nThis participant’s signature over the message.\nPerformed once by each participant selected for the …\nTests if a signature share issued by a participant is …")