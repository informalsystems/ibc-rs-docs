searchState.loadedDescShard("penumbra_sdk_shielded_pool", 0, "Returns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDecrypts the encrypted backref, returning a backref if the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA circuit that converts a private amount of one asset into …\nA proof that one asset was correctly converted into …\nThe private input for a <code>ConvertProof</code>.\nThe public input for a <code>ConvertProof</code>.\nThe private amount of the source asset we’re converting.\nThe blinding we used to create the public commitment.\nA commitment to the balance of this transaction: what …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe source asset being consumed.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerate a <code>ConvertProof</code>\nThe exchange rate: how many units of <code>to</code> we get for each …\nThe destination asset being produced.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHow long users have to switch to updated parameters.\nUse a fixed precision forever.\nThe state for the fixed algorithm\nMeta parameters governing how FMD parameters change.\nIf any, the current state for the algorithm we’re using.\nA catch-all case to allow us to explicitly handle not …\nA struct holding params for the sliding window algorithm\nUse a sliding window\nThe state for the sliding window algorithm.\nThe block height at which these parameters became …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFMD Precision.\nThe approximate number of clues in the previous window.\nA (transparent) genesis allocation.\nThe initial token allocations.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe initial FMD parameters.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA plaintext Penumbra note.\nA note ciphertext.\nA commitment to a note or swap.\nCreate the note commitment for this note.\nCreate a note commitment from its parts.\nCreate a note commitment from the blinding factor, value, …\nDecrypt a note ciphertext using the IVK and ephemeral …\nDecrypt wrapped OVK to generate the transmission key and …\nDecrypt a note ciphertext using the wrapped OVK to …\nDecrypt a note ciphertext using the <code>PayloadKey</code>.\nEncrypt a note, returning its ciphertext.\nGenerate encrypted outgoing cipher key for use with this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nObtain a note corresponding to this allocation.\nGenerate a fresh note representing the given value for the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParse a hex string as a [<code>Commitment</code>].\nGenerate a random [<code>Commitment</code>].\nGroth16 proof for correct nullifier derivation.\nThe private input for a [‘NullifierDerivationProof’].\nThe public input for a [‘NullifierDerivationProof’].\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe nullifier deriving key.\nA commitment to the spent note.\nnullifier of the spent note.\nThe position of the spent note.\nCalled to verify the proof using the provided public …\nPublic:\nA planned <code>Output</code>.\nThe private input for an <code>OutputProof</code>.\nThe public input for an <code>OutputProof</code>.\nA blinding factor to hide the balance of the transaction.\nA hiding commitment to the balance.\nCreate a dummy <code>OutputPlan</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether this plan’s output is viewed by the given …\nCreate a new <code>OutputPlan</code> that sends <code>value</code> to <code>dest_address</code>.\nThe note being created.\nA hiding commitment to the note.\nConvenience method to construct the <code>Output</code> described by …\nConstruct the [<code>output::Body</code>] described by this plan.\nConstruct the <code>OutputProof</code> required by the [<code>output::Body</code>] …\nGenerate an <code>OutputProof</code> given the proving key, public …\nCalled to verify the proof using the provided public …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe rseed is a uniformly random 32-byte sequence included …\nDerive the ephemeral secret key from the rseed.\nDerive note commitment randomness from the rseed.\nReturns the argument unchanged.\nGenerate a new rseed from a random source.\nCalls <code>U::from(self)</code>.\nGroth16 proof for spending existing notes.\nA planned <code>Spend</code>.\nThe private input for a <code>SpendProof</code>.\nThe public input for a <code>SpendProof</code>.\nThe spend authorization key.\nthe merkle root of the state commitment tree.\nbalance commitment of the note to be spent.\nCreate a dummy <code>SpendPlan</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>SpendPlan</code> that spends the given <code>position</code>ed …\nThe nullifier deriving key.\nThe note being spent.\nConstruct the <code>Nullifier</code> associated with this <code>SpendPlan</code>.\nnullifier of the note to be spent.\nGenerate a <code>SpendProof</code> given the proving key, public inputs,\nConstruct the randomized verification key associated with …\nthe randomized verification spend key.\nConvenience method to construct the <code>Spend</code> described by …\nThe randomizer used for generating the randomized spend …\nConstruct the [<code>spend::Body</code>] described by this <code>SpendPlan</code>.\nConstruct the <code>SpendProof</code> required by the [<code>spend::Body</code>] …\nInclusion proof for the note commitment.\nThe blinding factor used for generating the balance …\nCalled to verify the proof using the provided public …")