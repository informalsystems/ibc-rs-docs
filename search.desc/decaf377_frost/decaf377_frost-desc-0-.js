searchState.loadedDescShard("decaf377_frost", 0, "Threshold signing for <code>decaf377-rdsa</code> signatures via FROST.\nThe ciphersuite does not support DKG.\nError deserializing value.\nThis identifier is duplicated.\nDuplicated shares provided\nA FROST-related error.\nError in scalar Field.\nError in elliptic curve Group.\nA FROST participant identifier.\nThe ciphersuite does not support deriving identifiers from …\nCommitment equals the identity\nThe participant’s commitment is incorrect\nIncorrect number of commitments.\nIncorrect number of identifiers.\nIncorrect number of packages.\nIncorrect number of shares.\nThe incorrect package was specified.\nError in coefficient commitment deserialization.\nmax_signers is invalid\nmax_signers is invalid\nmin_signers is invalid\nThe proof of knowledge is not valid.\nSecret share verification failed.\nSignature verification failed.\nSignature share verification failed.\nThis identifier is unserializable.\nThe encoding of a signature was malformed.\nThe encoding of a signing key was malformed.\nThe encoding of a verifying key was malformed.\nThe participant’s commitment is missing from the Signing …\nRound 1 package not found for Round 2 participant.\nError serializing value.\nGenerated by the coordinator of the signing operation and …\nThis identifier does not belong to a participant in the …\nVerifies each FROST participant’s signature share, and …\nLike <code>aggregate</code>, but for generating signatures with a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFROST key shares and key generation.\nCreate a new <code>SigningPackage</code>\nSigning round 1 functionality and types.\nSigning Round 2 functionality and types.\nGet a signing commitment by its participant identifier, or …\nThe identifier of the signer whose share validation failed.\nThe identifier of the signer whose share validation failed.\nA user-provided list of identifiers.\nUse the default values (1 to max_signers, inclusive).\nThe identifier list to use when generating key shares.\nA FROST keypair, which can be generated either by a …\nPublic data that contains all the signers’ public keys …\nSecret and public key material generated by a dealer …\nA secret scalar value representing a signer’s share of …\nContains the commitments to the coefficients for our …\nA valid verifying key for Schnorr signatures over a FROST […\nA public group element that represents a single signer’s …\nDistributed key generation without a trusted dealer.\nAllows all participants’ keys to be generated using a …\nRecompute the secret from t-of-n secret shares using …\nSplits an existing key into FROST shares.\nPerforms the first part of the distributed key generation …\nPerforms the second part of the distributed key generation …\nPerforms the third and final part of the distributed key …\nDKG Round 1 structures.\nDKG Round 2 structures.\nThe package that must be broadcast by each participant to …\nThe secret package that must be kept in memory by the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA package that must be sent by each participant to some …\nThe secret package that must be kept in memory by the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPublished by each participant in the first round of the …\nThe nonces used for a single FROST signing ceremony.\nPerformed once by each participant selected for the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA FROST participant’s signature share, which the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPerformed once by each participant selected for the …\nLike <code>sign</code>, but for producing signatures with a randomized …")