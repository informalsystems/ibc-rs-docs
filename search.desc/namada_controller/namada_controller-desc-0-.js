searchState.loadedDescShard("namada_controller", 0, "Inflation PD-controller\nA 256 bit number with <code>POS_DECIMAL_PRECISION</code> number of Dec …\nMaximum value.\nLittle-endian large integer type Namada native type to …\nGet the absolute value of self as integer\nGet the non-negative difference between two <code>Dec</code>s.\nComputes the absolute difference between self and other.\nArithmetics helpers\nConversion to u128 with overflow checking\nConversion to u32 with overflow checking\nConversion to u64 with overflow checking\nConversion to usize with overflow checking\nReturn if specific bit is set.\nReturn the least number of bits needed to represent the …\nReturn the least number of bits needed to represent the …\nReturn specific byte.\nReturn the integer value of a <code>Dec</code> by rounding up.\nDo addition of two <code>Dec</code>s\nChecked addition. Returns <code>None</code> if overflow occurred.\nChecked division\nChecked division. Returns <code>None</code> if <code>other == 0</code>.\nChecked multiplication. Return <code>None</code> if overflow. This …\nChecked multiplication. Returns <code>None</code> if overflow occurred.\nReturns a pair …\nChecked negation\nChecked negation. Returns <code>None</code> unless <code>self == 0</code>.\nChecked exponentiation. Returns <code>None</code> if overflow occurred.\nChecked modulus. Returns <code>None</code> if <code>other == 0</code>.\nDo subtraction of two <code>Dec</code>s\nChecked subtraction. Returns <code>None</code> if overflow occurred.\nCompute inflation amount\nReturns a pair <code>(self / other, self % other)</code>.\nReturns a pair <code>(self / other, self % other)</code>.\nCreate <code>10**n</code> as this type.\nDivide two <code>Uint</code>s with scaled to allow the <code>denom</code> number of …\nReturn the ceiling of the product of an integer and a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts from big endian representation bytes in memory.\nConvert from a decimal string.\nConverts from little endian representation bytes in memory.\nConverts a string slice in a given base to an integer. …\nConvert a <code>u64</code> to a <code>Uint</code>.\nGet epochs per year\nGet total native amount as decimal\nCompute the highest <code>n</code> such that <code>n * n &lt;= self</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn if the <code>Dec</code> is negative\nCheck if value is zero\nWhether this is zero.\nReturns the number of leading zeros in the binary …\nLow 2 words (u128)\nConversion to u32\nLow word (u64)\nThe maximum value which can be inhabited by this type.\nInstantiate a new PD-controller\nCreate a new <code>Dec</code> using a mantissa and a scale.\nThe representation of 1\nOne (multiplicative identity) of this type.\nThe representation of 1 / 3\nAddition which overflows and returns a flag if it does.\nMultiply with overflow, returning a flag if it does.\nNegation with overflow.\nFast exponentiation by squaring. Returns result and …\nSubtraction which underflows and returns a flag if it does.\nFast exponentiation by squaring …\nAddition which saturates at the maximum value (Self::MAX).\nMultiplication which saturates at the maximum value..\nSubtraction which saturates at zero.\nWrite to the slice in big-endian format.\nConvert the Dec type into a I256 with truncation\nWrite to the slice in little-endian format.\nConvert the Dec type into a Uint with truncation\nReturns the number of trailing zeros in the binary …\nPerforms division with truncation.\nThe representation of 2\nThe representation of 2 / 5\nThe representation of 2 / 3\nThe representation of 0\nZero (additive identity) of this type.\nPerforms addition that returns <code>None</code> instead of wrapping …\nPerforms division that returns <code>None</code> instead of panicking …\nPerforms multiplication that returns <code>None</code> instead of …\nPerforms negation that returns <code>None</code> if the result can’t …\nPerforms an integral remainder that returns <code>None</code> instead …\nPerforms subtraction that returns <code>None</code> instead of wrapping …\nChecked arithmetics error.\nPerforms addition with a flag for overflow.\nPerforms substraction with a flag for overflow.\nConvert arithmetic operators within the given expression …\nAdds two numbers, checking for overflow. If overflow …\nDivides two numbers, checking for underflow, overflow and …\nMultiplies two numbers, checking for underflow or …\nNegates a number, returning <code>None</code> for results that can’t …\nFinds the remainder of dividing two numbers, checking for …\nSubtracts two numbers, checking for underflow. If …\nThe original expression given to the <code>checked</code> macro.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns a tuple of the sum along with a boolean indicating …\nReturns a tuple of the difference along with a boolean …")