searchState.loadedDescShard("namada_tx_env", 0, "Transaction environment contains functions that can be …\nAn account’s address\nA data-structure that can be de-serialized from binary …\nmoved to docs of <strong>Derive Macro</strong> <code>BorshDeserialize</code> in <code>borsh</code> …\nA data-structure that can be serialized into binary format …\nmoved to docs of <strong>Derive Macro</strong> <code>BorshSerialize</code> in <code>borsh</code> crate\nExtensions to types implementing <code>BorshSerialize</code>.\nThe domain of the event to emit.\nContains the error value\nAn established address is generated on-chain\nCustom events that can be queried from Tendermint using a …\nAn event to be emitted in Namada.\nABCI event type.\nAn implicit address is derived from a cryptographic key\nAn internal address represents a module with a native VP\nA MASP transaction.\nContains the success value\nStorage read prefix iterator\nResult of a storage API call.\nResult extension to easily wrap custom errors into <code>Error</code>.\nCommon storage read interface\nCommon storage write interface\nTransaction host functions\nReturn a reference to the event’s attributes.\nReturn a mutable reference to the event’s attributes.\nRequest to charge the provided amount of gas for the …\nDecode an address from Bech32m encoding\nDelete a value at the given key from storage.\nDelete all key-vals with a matching prefix.\nDeserializes this instance from a given slice of bytes. …\nRetrieve the domain of some event.\nCompute the gas cost of emitting this event. Returns <code>None</code> …\nEmit an <code>Event</code> from a transaction.\nEncode an address with Bech32m encoding\nExtend this <code>Event</code> with additional data.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGetting the block epoch. The epoch is that of the block to …\nGetting the block header.\nGetting the block height. The height is that of the block …\nGetting the chain ID.\nGet the height of the first block of the current epoch.\nGiven the epoch at the given block height.\nGet the height of the first block of the given epoch.\nGet events with a given <code>EventType</code>.\nGet the native token address\nGiven the information about predecessor block epochs\nGet the transaction index.\nCheck if a certain attribute is present in the event.\nStorage <code>has_key</code> in. It will try to read from the storage.\nCheck if this <code>Event</code> has a subset of the keys and values in …\nInitialize a new account generates a new established …\nInsert a verifier address. This address must exist on …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the attributes of the event, destroying it in the …\nConvert a <code>std::result::Result</code> into storage_api <code>Result</code>.\nIf the address established?\nIf the address implicit?\nIf the address internal?\nStorage prefix iterator. It will try to read from the …\nStorage prefix iterator ordered by the storage keys. It …\nReturn the type of the event.\nReturn the level of the event.\nJoins the attribute sets of two <code>Event</code>\nCreate a new event type.\nCreate a new event with no attributes and the given …\nTry to get a raw hash of an address, only defined for …\nGet the raw string value corresponding to a given …\nStorage read Borsh encoded value. It will try to read from …\nGet the value corresponding to a given attribute.\nGet the value corresponding to a given attribute, if it …\nStorage read raw bytes. It will try to read from the …\nStorage read temporary state raw bytes (after tx …\nStorage read temporary state Borsh encoded value (after tx …\nSerialize a value to a <code>Vec</code> of bytes.\nSet the sentinel for an invalid section commitment\nStorage types\nRetrieve the sub-domain of some event.\nPrint the type of the address and its bech32m encoded value\nDeserialize this instance from a slice of bytes.\nUpdate the masp note commitment tree in storage with the …\nUpdate a validity predicate\nAdd a static message to a possible error in <code>Result</code>.\nWrite a value to be encoded with Borsh at the given key to …\nWrite a value as bytes at the given key to storage.\nWrite a temporary value as bytes at the given key to …\nWrite a temporary value to be encoded with Borsh at the …\nA segment made of an address\nBlock\nBlock column family name\nRepresents the indices of the accepted transactions in a …\nDiffs\nDiffs column family name\nStorage column families\nA storage key segment\nThe length of the epoch type\nContains the error value\nContainer of all Ethereum event queues.\nDraining iterator over a queue of Ethereum events,\nThe maximum size of an IBC key (in bytes) allowed in …\nA queue of confirmed Ethereum events of type <code>E</code>.\nThe separator of storage key segments\nA storage key is made of storage key segments <code>DbKeySeg</code>, …\nA <code>Key</code> made of borrowed key segments <code>DbKeySeg</code>.\nRepresents a segment in a path that may be used as a …\nContains the success value\nA value of a storage prefix iterator.\nReplay protection\nReplay protection column family name\nThe reserved storage key prefix for addresses\nThe reserved storage key for validity predicates\nDiffs for rollback (only kept for 1 block)\nDiffs for rollback (only kept for 1 block) column family …\nResult for functions that may fail\nState\nState column family name\nSubspace\nSubspace column family name\nStorage keys that are utf8 encoded strings\nAny other key segment\nThe length of the transaction index\nA wrapper around raw bytes to be stored as values in a …\nTransaction index within block.\nThe reserved storage key prefix for validity predicates\nThe reserved storage key prefix for wasm codes’ length\nThe reserved storage key prefix for wasm codes’ name\nThe reserved storage key prefix for wasm codes\nThe reserved storage key prefix for wasm code hashes\nThe reserved storage key prefix for wasm codes\nAccept the tx at the given position.\nReturn an array of all column families\nChecked index addition.\nCheck if <code>KeyRef</code> is equal to a <code>Key</code>.\nReturns the addresses from the key segments\nReturns the first segment of the key, or <code>None</code> if it is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the address from the first key segment if it’s …\nReturn the segment at the index parameter\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the tx at the given position is accepted.\nReturns <code>true</code> if the key is empty\nCheck if the given key is a key to a validity predicate. …\nCheck if an instance is the zero value\nIterates over all addresses in the key segments\nReturn an iterator over the removed txs in this …\nReturns a new key with segments of <code>Self</code> and the given key\nStorage key\nReturns the last segment of the key, or <code>None</code> if it is …\nReturns the length\nThe length of the input (without the padding)\nConvert from a <code>usize</code> or panic.\nReturn an Ethereum events queue starting at the specified …\nThe original key string, in bytes\nReverse of <code>into_string</code>. Convert key segment to <code>Self</code>.\nParses string and returns a key\nReturns a key from the given DB key path that has the …\nReturns a new key with segments of <code>Self</code> and the given …\nPush a new Ethereum event of type <code>E</code> into the queue, and …\nConvert <code>Self</code> to a string.\nReject the tx at the given position.\nThe segments of the key in the original (left-to-right) …\nReference of key segments\nReturns the prefix before the last segment and last …\nReturns the prefix before the last segment and last …\nCheck if the key begins with the given prefix and returns:\nReturns a sub key without the first segment\nConvert <code>Self</code> to a key segment. This mapping should …\nGet the name of the column family\nQueue of transfer to Namada events.\nThe utf8 bytes representation of the key to be used …\nReturns a key of the validity predicate of the given …\nRaw value bytes\nReturns a key of the wasm code of the given hash\nReturns a key of the wasm code’s length of the given hash\nReturns a key of wasm code’s hash of the given name\nReturns a key of the wasm code hash of the given code path\nTakes ownership of the key, appends a new segment to it, …\nThe value indicating that a leaf should be deleted")