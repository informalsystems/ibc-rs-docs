searchState.loadedDescShard("namada_trans_token", 0, "Transparent token types, storage functions, and validation.\nAmount in micro units. For different granularity another …\nIndicates an event is to do with a finalized block.\nA change in tokens amount\nAn amount with its denomination.\nGiven a number represented as <code>M*B^D</code>, then <code>M</code> is the …\nContains the error value\nContains the error value\nIndicates if an event is emitted do to an individual Tx or …\nAbstract token events interface\nExternal chain address.\nInternal chain address in Namada.\nA storage key is made of storage key segments <code>DbKeySeg</code>, …\nAbstract token keys interface\nThe four possible u64 words in a <code>Uint</code>. Used for converting …\nMaximum decimal places in a native token <code>Amount</code> and <code>Change</code>.\nDecimal scale of a native token <code>Amount</code> and <code>Change</code>. For …\nContains the success value\nContains the success value\nStorage read prefix iterator\nAbstract token storage read interface\nResult of a storage API call.\nResult of a storage API call.\nResult extension to easily wrap custom errors into <code>Error</code>.\nCommon storage read interface\nCommon storage write interface\nTransparent token storage <code>Keys/Read/Write</code> implementation\nIndicates an event is to do with an individual transaction.\nA user account.\nAbstract token storage write interface\nReturns the significand of this number\nKey for transparent token balance\nBurn a specified amount of tokens from some address.\nBurn a specified amount of tokens from some address. If …\nCheck if there are enough funds.\nFind the minimal precision that holds this value …\nGet the amount as a <code>Change</code>\nChecked addition. Returns <code>None</code> on overflow or if the …\nChecked addition. Returns <code>None</code> on overflow.\nChecked division. Returns <code>None</code> on underflow.\nDivide by <code>u64</code> with zero divisor and overflow check.\nChecked multiplication. Returns <code>None</code> on overflow.\nChecked multiplication. Returns <code>None</code> on overflow.\nChecked addition. Returns <code>None</code> on overflow or if the …\nChecked subtraction. Returns <code>None</code> on underflow.\nChecked subtraction. Returns <code>None</code> on overflow.\nCredit tokens to an account, to be used only by protocol. …\nCredit tokens to an account, to be used only by protocol. …\nDecrement the balance of a given token and owner.\nDecrement the total network supply of a given token.\nDelete a value at the given key from storage.\nDelete all key-vals with a matching prefix.\nReturns the denomination of this number\nConvert this denominated amount into a plain amount by …\nGet the corresponding u64 word from the input uint256.\nAdd denomination info if it exists in storage.\nAttempt to downgrade the inner error to <code>E</code> if any.\nReturns some reference to the inner value if it is of type …\nEmit burn token event\nEmit mint token event\nEmit transfer token event\nToken transaction events.\nReturns the addresses from the key segments\nReturns the first segment of the key, or <code>None</code> if it is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate amount from the absolute value of <code>Change</code>.\nGiven a u64 and <code>MaspDigitPos</code>, construct the corresponding …\nGiven a i128 and <code>MaspDigitPos</code>, construct the corresponding …\nGiven a string and a denomination, parse an amount from …\nConvert to an <code>Amount</code> under the assumption that the input …\nConvert a <code>u128</code> to an <code>Amount</code>.\nConvert a <code>u64</code> to an <code>Amount</code>.\nAttempt to convert an unsigned integer to an <code>Amount</code> with …\nReturns the address from the first key segment if it’s …\nReturn the segment at the index parameter\nGetting the block epoch. The epoch is that of the block to …\nGetting the block header.\nGetting the block height. The height is that of the block …\nGetting the chain ID.\nGet the height of the first block of the current epoch.\nGet the effective circulating total supply of native …\nGet the effective circulating total supply of native …\nGiven the epoch at the given block height.\nGet the height of the first block of the given epoch.\nGet the native token address\nGiven the information about predecessor block epochs\nGet the transaction index.\nStorage <code>has_key</code> in. It will try to read from the storage.\nAttempt to increase the precision of an amount. Can fail …\nIncrement the balance of a given token and owner.\nIncrement the total network supply of a given token.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert a <code>std::result::Result</code> into storage_api <code>Result</code>.\nCheck if the given storage key is for total supply of a …\nCheck if the given storage key is a balance key for an …\nReturns the owner address if the given storage key is a …\nReturns <code>true</code> if the key is empty\nCheck if <code>Amount</code> is greater than zero.\nCheck if the given key is a key to a validity predicate. …\nCheck if <code>Amount</code> is zero.\nCheck if the inner <code>Amount</code> is zero.\nIterator over the possible denominations\nIterates over all addresses in the key segments\nStorage prefix iterator. It will try to read from the …\nStorage prefix iterator ordered by the storage keys. It …\nIterate over all words in this <code>Amount</code>.\nReturns a new key with segments of <code>Self</code> and the given key\nReturns the last segment of the key, or <code>None</code> if it is …\nReturns the length\nCreate a new amount with the maximum value\nCreate a new amount with the maximum signed value\nMint <code>amount</code> of <code>token</code> as <code>minter</code> to <code>dest</code>.\nObtain a storage key for the minted multitoken balance.\nObtain a storage key for the multitoken minter.\nMultiply by a decimal <code>Dec</code> with the result rounded up. …\nMultiply by a decimal <code>Dec</code> with the result rounded down. …\nReturn a denominated native token amount.\nReturn a denominated native token amount.\nCreate a new amount of native token from whole number of …\nCreate an <code>Error</code> from another <code>std::error::Error</code>.\nMake a new denominated amount representing amount*…\nCreate an <code>Error</code> from a heap allocated message.\nCreate an <code>Error</code> from a static message.\nObtain a storage key prefix for token parameters.\nParses string and returns a key\nReturns a key from the given DB key path that has the …\nReturns a new key with segments of <code>Self</code> and the given …\nGet the raw <code>Uint</code> value, which represents namnam\nStorage read Borsh encoded value. It will try to read from …\nRead the balance of a given token and owner.\nRead the balance of a given token and owner.\nStorage read raw bytes. It will try to read from the …\nRead the denomination of a given token, if any. Note that …\nRead the denomination of a given token, if any. Note that …\nRead the total network supply of a given token.\nReceive a given amount.\nMultiply this number by 10^denom and return the computed …\nThe segments of the key in the original (left-to-right) …\nSpend a given amount.\nReturns the prefix before the last segment and last …\nCheck if the key begins with the given prefix and returns:\nTransparent token storage keys\nReturns a sub key without the first segment\nSum with overflow check\nGet a string representation of a native token amount.\nA precise string representation. The number of decimal …\nApply transfer of a <code>token</code> from <code>src</code> to <code>dest</code> in storage.\nTransfer <code>token</code> from <code>src</code> to <code>dest</code>. Returns an <code>Err</code> if <code>src</code> has …\nToken transfers\nA combination of Euclidean division and fractions: x*(a,b) …\nUpdate the balance of a given token and owner.\nUpdate the total network supply of a given token.\nReturns a key of the validity predicate of the given …\nNative VP for multitokens\nReturns a key of the wasm code of the given hash\nReturns a key of the wasm code’s length of the given hash\nReturns a key of wasm code’s hash of the given name\nReturns a key of the wasm code hash of the given code path\nTakes ownership of the key, appends a new segment to it, …\nWrap another <code>std::error::Error</code> with a static message.\nAdd a static message to a possible error in <code>Result</code>.\nWrite a value to be encoded with Borsh at the given key to …\nWrite a value as bytes at the given key to storage.\nWrite the denomination of a given token.\nInitialize parameters for the token in storage during the …\nZero <code>Amount</code>.\nExtend an <code>Event</code> with amount data.\nToken burn operation.\nToken burn event.\nExtend an <code>Event</code> with token event descriptor data.\nToken mint operation.\nToken mint event.\nExtend an <code>Event</code> with source post balance data.\nExtend an <code>Event</code> with source account data.\nExtend an <code>Event</code> with source account data.\nExtend an <code>Event</code> with source post balance data.\nExtend an <code>Event</code> with target account data.\nExtend an <code>Event</code> with target account data.\nExtend an <code>Event</code> with target post balance data.\nExtend an <code>Event</code> with token address data.\nNamada token event.\nToken event kind.\nNamada token operation.\nToken transfer operation.\nToken transfer event.\nAdditional description of the token event.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe token event kind associated with this operation.\nThe event level.\nThe operation that took place.\nConstruct a simple transfer operation\nToken event types.\nThe amount of minted tokens.\nThe amount of minted tokens.\nThe balance that <code>target_account</code> ended up with.\nThe balance that <code>target_account</code> ended up with.\nThe balance that <code>sources</code> and <code>targets</code> ended up with.\nThe source of the token transfer.\nThe target account whose balance was changed.\nThe target account whose balance was changed.\nThe target of the token transfer.\nThe affected token address.\nThe affected token address.\nBurn token event.\nMint token event.\nTransfer token event.\nKey segment for a balance key\nKey segment for a denomination key\nKey segment for minted balance\nKey segment for multitoken minter\nKey segment for token parameters\nObtain a storage key for user’s balance.\nObtain a storage key prefix for all users’ balances.\nObtain a storage key denomination of a token.\nCheck if the given storage key is for total supply of a …\nCheck if the given storage key is for a minter of a …\nCheck if the given storage key is a balance key for an …\nCheck if the given storage key is a parameter key for an …\nCheck if the given storage key is a balance key for the …\nCheck if the given storage key is a denomination key for …\nCheck if a key is part of the multitoken vp sub storage\nGets the key for the given token address, error with the …\nObtain a storage key for the minted multitoken balance.\nObtain a storage key for the multitoken minter.\nObtain a storage key prefix for token parameters.\nMulti-transfer credit or debit amounts\nReturns a reference to the value corresponding to pair of …\nGets an owning iterator over the pairs of credited or …\nGets an iterator over the pair of credited or debited …\nTransfer tokens from <code>sources</code> to <code>dests</code>.\nTransfer transparent token, insert the verifier expected …\nMultitoken VP\nGeneric types for DI\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn the minter if the minter is valid and the minter VP …\nReturn if the parameter change was done via a governance …\nRun the validity predicate")