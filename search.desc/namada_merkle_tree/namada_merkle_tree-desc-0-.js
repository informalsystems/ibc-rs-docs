searchState.loadedDescShard("namada_merkle_tree", 0, "The merkle tree in the storage\nFor Account and other data\nFor Account and other data\nFor Account and other data\nArse-merkle-tree\nArse-merkle-tree store\nBase tree, which has roots of the subtrees\nBase tree, which has roots of the subtrees\nBase tree, which has roots of the subtrees\nHeight of a block, i.e. the level. The <code>default</code> is the …\nBespoke membership proof for the Ethereum bridge pool\nFor the Ethereum bridge Pool transfers\nFor the Ethereum bridge Pool transfers\nFor the Ethereum bridge Pool transfers\nBridge pool store\nFor the commit only data\nFor commit only data\nFor the commit only data\nFake merkle tree just to commit extra data to the merkle …\nCommitmentProof is either an ExistenceProof or a …\nEpoch identifier. Epochs are identified by consecutive …\nRepresent 256 bits\nA hash, typically a sha-2 hash of a tx\nICS23 compliant membership proof\nFor IBC-related data\nFor IBC-related data\nFor IBC-related data\nRepresents a Keccak hash.\nA storage key is made of storage key segments <code>DbKeySeg</code>, …\nType of membership proof from a merkle tree\nThe root hash of the merkle tree as bytes\nMerkle tree storage\nThe root and store pairs to restore the trees\nThe root and store pairs to be persistent\nKey prefix for the data not stored to diffs\nFor data not stored to diffs\nFor data not stored to diffs\nFor data not stored to diffs\nFor PoS-related data\nFor PoS-related data\nFor PoS-related data\nA storage key existence or non-existence proof\nSparse-merkle-tree\nSparse-merkle-tree store\nType alias for bytes to be put into the Merkle storage\nThe storage hasher used for the merkle tree.\nBacking storage for merkle trees\nPointer to backing storage of merkle tree\nStore types for the merkle tree\nTrait for reading from a merkle tree that is a sub-tree of …\nTrait for updating a merkle tree that is a sub-tree of the …\nReturn the inner pointer to the hash data.\nConvert to a <code>StoreRef</code> with borrowed store\nBase proof\nChecked epoch addition.\nChecked block height addition.\nChecked epoch division.\nChecked epoch multiplication.\nChecked epoch integral reminder.\nChecked epoch subtraction. Computes self - rhs, returning …\nChecked block height subtraction.\nGiven hashes A and B, compute Sha256(A||B), but if one …\nCopy bits and return a new H256\nDecode the backing store from bytes and tag its type …\nDelete the value corresponding to the given key\nBorsh Seriliaze the backing stores of our Merkle tree.\nEthereum bridge pool merkle tree\nReturns the addresses from the key segments\nReturns the first segment of the key, or <code>None</code> if it is …\nThe first block height 1.\nTreat H256 as a path in a tree fork height is the number …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the address from the first key segment if it’s …\nGet the value in the tree\nReturn the segment at the index parameter\nStorage key for commit data\nGet the non-existence proof\nRead the merkle root of the requested type\nRead the backing store of the requested type\nGet the existence proof from a sub-tree\nGet the Tendermint proof with the base proof\nHash the value to store\nA module that contains\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the key is empty\nReturn true if the subtree should be saved in every block\nCheck if the given key is a key to a validity predicate. …\nCheck if the hash is all zeros\nCheck if this <code>KeccakHash</code> is comprised solely of bytes with …\nGet an iterator for the base tree and subtrees\nIterates over all addresses in the key segments\nIterate a range of epochs, inclusive of the start and end.\nGet an iterator for the non-provable subtrees\nGet an iterator for the provable subtrees\nIterate a range of consecutive epochs starting from <code>self</code> …\nGet an iterator for subtrees\nReturns a new key with segments of <code>Self</code> and the given key\nStorage key\nReturns the last segment of the key, or <code>None</code> if it is …\nReturn the length of the hash.\nReturns the length\nRestore the full tree from the stores\nRestore the partial tree from the stores without validation\nChange to the next epoch\nGet the height of the next block\nTreat H256 as a path in a tree return parent_path of self\nParses string and returns a key\nReturns a key from the given DB key path that has the …\nChange to the previous epoch.\nGet the height of the previous block\nGet the key prefix if the store type is for a provable …\nReturns a new key with segments of <code>Self</code> and the given …\nGet the root of a subtree in raw bytes.\nGet the root of the given store type\nGet the root\nChecked epoch subtraction. Computes self - rhs, returning …\nThe segments of the key in the original (left-to-right) …\nA sentinel value block height 0 may be used before any …\nSet the root of the given store type\nSet the store of the given store type\nCompute sha256 of some bytes\nReturns the prefix before the last segment and last …\nCheck if the key begins with the given prefix and returns:\nGet the store of the given store type\nGet the stores of the base and sub trees\nGet the store type and the sub key\nReturns a sub key without the first segment\nSub proof\nGet the root of a sub-tree\nDelete a key from the sub-tree\nGet the height at which the key is inserted\nCheck if a key is present in the sub-tree\nGet a membership proof for various key-value pairs\nAdd a key-value pair to the sub-tree\nGet owned copies of backing stores of our Merkle tree.\nConvert this <code>Hash</code> to a <code>Vec</code>.\nGet the key prefix with which the tree root and store are …\nGet the key prefix with which the tree root and store are …\nUnchecked epoch addition.\nUpdate the tree with the given key and value\nUpdate the commit data subtree\nRecompute the merkle root from the backing storage and …\nRecalculate the merkle tree root of storage and compare it …\nReturns a key of the validity predicate of the given …\nReturns a key of the wasm code of the given hash\nReturns a key of the wasm code’s length of the given hash\nReturns a key of wasm code’s hash of the given name\nReturns a key of the wasm code hash of the given code path\nTakes ownership of the key, appends a new segment to it, …\nReturn zeros\nA multi-leaf membership proof\nA simple Merkle tree for the Ethereum bridge pool\nGeneric error that may be returned by the validity …\nA transfer message to Ethereum sitting in the bridge pool, …\nRetrieve a reference to the appendix of this …\nParse the key to ensure it is of the correct type.\nDelete a key from storage and update the root\nFlags are used to indicate which consecutive pairs of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCraft a <code>PendingTransfer</code> from its constituents.\nAmount of gas fees paid by the user sending the transfer.\nGet the height at which the key was inserted\nCreate a batched membership proof for the provided keys\nUpdate the tree with a new value.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRetrieve the owned appendix of this <code>PendingTransfer</code>.\nThe leaves; must be sorted\nCreate a new merkle tree for the Ethereum bridge pool\nParse a db key to see if it is valid for the bridge pool.\nThe hashes other than the provided leaves\nReturn the root as a <code>Hash</code> type.\nGet a reference to the backing store\nGet a token <code>Address</code> from this <code>PendingTransfer</code>.\nTransfer to Ethereum data.\nRecomputes the root and check if it matches the …\nVerify a membership proof matches the provided root\nGet the leaf spec for the base tree. The key is stored …\nGet the leaf spec for the ibc subtree.\nGet the proof specs for ibc\nGet the leaf spec for the subtree. Non-hashed values are …\nGet the proof specs")