searchState.loadedDescShard("nam_jubjub", 0, "This crate provides an implementation of the <strong>Jubjub</strong> …\nThis is a pre-processed version of an affine point <code>(u, v)</code> …\nThis represents a Jubjub point in the affine <code>(u, v)</code> …\nRepresents an element of the base field $\\mathbb{F}_q$ of …\nThis is a pre-processed version of an extended point …\nThis represents an extended point <code>(U, V, Z, T1, T2)</code> with <code>Z</code> …\nRepresents an element of the scalar field $\\mathbb{F}_q$ …\nRepresents an element of the scalar field $\\mathbb{F}_r$ …\nRepresents an element of the scalar field $\\mathbb{F}_r$ …\nThis represents a point in the prime-order subgroup of …\nAdds this element to another element.\nAdds <code>rhs</code> to <code>self</code>, returning the result.\nAttempts to interpret a batch of byte representations of …\nThis takes a mutable slice of <code>ExtendedPoint</code>s and “…\nReturns the identity.\nReturns the identity.\nDoubles this field element.\nComputes the doubling of a point more efficiently than a …\nDoubles this field element.\nReturns the argument unchanged.\nConstructs an affine point from an extended point using …\nReturns the argument unchanged.\nConstructs an extended point (with <code>Z = 1</code>) from an affine …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to convert a little-endian byte representation of …\nAttempts to interpret a byte representation of an affine …\nAttempts to convert a little-endian byte representation of …\nAttempts to interpret a byte representation of an affine …\nConverts a 512-bit little endian integer into an element …\nConverts a 512-bit little endian integer into a <code>Scalar</code> by …\nConverts from an integer represented in little endian into …\nConverts from an integer represented in little endian into …\nConstructs an AffinePoint given <code>u</code> and <code>v</code> without checking …\nConstructs an AffinePoint given <code>u</code> and <code>v</code> without checking …\nReturns the <code>u</code>-coordinate of this point.\nReturns the <code>v</code>-coordinate of this point.\nConstructs the neutral element <code>(0, 1)</code>.\nConstructs an extended point from the neutral element …\nConstructs this point from the neutral element <code>(0, 1)</code>.\nConstructs this point from the neutral element <code>(0, 1)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes the multiplicative inverse of this element, …\nComputes the multiplicative inverse of this element, …\nDetermines if this point is the identity.\nDetermines if this point is the identity.\nDetermines if this point is prime order, or in other words …\nDetermines if this point is prime order, or in other words …\nDetermines if this point is of small order.\nDetermines if this point is of small order.\nDetermines if this point is torsion free and so is in the …\nDetermines if this point is torsion free and so is …\nMultiplies this element by another element\nMultiplies <code>rhs</code> by <code>self</code>, returning the result.\nMultiplies this point by the cofactor, producing an …\nMultiplies this element by the cofactor <code>8</code>.\nMultiplies this point by the specific little-endian bit …\nMultiplies this point by the specific little-endian bit …\nNegates this element.\nThis computes the negation of a point <code>P = (u, v)</code> as …\nComputes the negation of a point <code>P = (U, V, Z, T)</code> as …\nNegates <code>self</code>.\nReturns one, the multiplicative identity.\nReturns one, the multiplicative identity.\nExponentiates <code>self</code> by <code>by</code>, where <code>by</code> is a little-endian …\nExponentiates <code>self</code> by <code>by</code>, where <code>by</code> is a little-endian …\nExponentiates <code>self</code> by <code>by</code>, where <code>by</code> is a little-endian …\nExponentiates <code>self</code> by <code>by</code>, where <code>by</code> is a little-endian …\nComputes the square root of this element, if it exists.\nSquares this element.\nSquares this element.\nSubtracts another element from this element.\nSubtracts <code>rhs</code> from <code>self</code>, returning the result.\nConverts an element of <code>Fr</code> into a byte representation in …\nConverts this element into its byte representation.\nConverts an element of <code>Scalar</code> into a byte representation in\nReturns an <code>ExtendedPoint</code> for use in arithmetic operations.\nPerforms a pre-processing step that produces an …\nPerforms a pre-processing step that produces an …\nReturns zero, the additive identity.\nReturns zero, the additive identity.")