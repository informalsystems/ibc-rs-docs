searchState.loadedDescShard("namada_state", 0, "Ledger’s state storage with key-value backed store and a …\nThe proposed block was accepted by this node with the …\nFor Account and other data\nFor Account and other data\nThe length of the block hash\nThe length of the block height\nBase tree, which has roots of the subtrees\nBase tree, which has roots of the subtrees\nHash of a block as fixed-size byte array\nThe block header data from Tendermint header relevant for …\nHeight of a block, i.e. the level. The <code>default</code> is the …\nRepresents the indices of the accepted transactions in a …\nThe block’s state as stored in the database.\nThe block’s state to write into the database.\nThe block storage data\nBespoke membership proof for the Ethereum bridge pool\nFor the Ethereum bridge Pool transfers\nFor the Ethereum bridge Pool transfers\nA DB’s cache\nFor commit only data\nFor the commit only data\nA representation of a leaf in the conversion tree\nA representation of the conversion state\nDB type\nA database backend.\nA database prefix iterator.\nAtomic batch write.\nA result of a function that may fail\nWe delay epoch change 2 blocks to keep it in sync with …\nThe length of the epoch type\nEpoch identifier. Epochs are identified by consecutive …\nPredecessor block epochs\nContains the error value\nContains the error value\nContainer of all Ethereum event queues.\nOwned state with full R/W access.\nDB hasher type\nICS23 compliant membership proof\nFor IBC-related data\nFor IBC-related data\nThe ledger’s state\nA key-value pair as raw bytes\nA storage key is made of storage key segments <code>DbKeySeg</code>, …\nRepresents a segment in a path that may be used as a …\nLast committed block\nType of membership proof from a merkle tree\nMerkle tree storage\nThe root and store pairs to restore the trees\nThe root and store pairs to be persistent\nA type placeholder for DB migration implementation.\nFor data not stored to diffs\nFor data not stored to diffs\nContains the success value\nContains the success value\nAn extension to <code>Option</code> to allow turning <code>None</code> case to an …\nPattern iterator\nStorage prefix iterator generic wrapper type.\nFor PoS-related data\nFor PoS-related data\nPrefix iterator for <code>StorageRead</code> implementations.\nPrefix iterator\nStorage read prefix iterator\nStorage prefix iterator generic wrapper type.\nThe result of process proposal that can be cached for …\nAble to borrow conversion state.\nThe proposed block was rejected by this node\nSource data to restore a database.\nResult of a storage API call.\nResult extension to easily wrap custom errors into <code>Error</code>.\nThe storage hasher used for the merkle tree.\nCommon trait for write log, DB and in-memory state.\nCommon trait for read-only access to write log, DB and …\nThe storage hasher used for the merkle tree.\nCommon storage read interface\nCommon storage write interface\nPointer to backing storage of merkle tree\nStore types for the merkle tree\nState with a temporary write log. This is used for …\nState with mutable write log and gas metering for tx host …\nTransaction index within block.\nPerform storage writes and deletions to write-log at tx …\nRead-only state with gas metering for VP host env.\nAble to borrow mutable conversion state.\nState with a write-logged storage.\nA handle for batch writes\nAccept the tx at the given position.\nWrite block’s metadata. Merkle tree sub-stores are …\nStore in memory a total gas of a transaction with the …\nEstablished address generator\nEstablished address generator\nThe current established address generator\nMap assets to their latest conversion and position in …\nStart write batch.\nStart write batch.\nBatch delete the value with the given height and account …\nBatch delete the value with the given height and account …\nBatch write the value with the given height and account …\nBatch write the value with the given height and account …\nBlock data is in the Merkle tree as it’s tracked by …\nBlock storage data\nCache of the results of process proposal for the next …\nThe ID of the chain\nTry to charge a given gas amount. Returns an error on …\nChecked index addition.\nChecked epoch addition.\nChecked block height addition.\nChecked epoch division.\nChecked epoch multiplication.\nChecked epoch integral reminder.\nChecked epoch subtraction. Computes self - rhs, returning …\nChecked block height subtraction.\nLazy data structures for storage access where elements are …\nCommit the current block’s write log to the storage and …\nPersist the block’s state from batch writes to the …\nCommit the data from in-memory state into the block’s …\nStructure holding data that needs to be added to the …\nStructure holding data that needs to be added to the …\nData that needs to be committed to the merkle tree\nCommit the current transaction’s write log and the …\nCommit the current block’s write log to the storage. …\nThe actual conversion and generator\nBorrow immutable conversion state\nThe conversion state\nThe conversion state\nThe currently saved conversion state\nBorrow mutable conversion state\nBorrow <code>DB</code>\nBorrow DB handle\nBorrow DB handle\nDB handle\nDB handle\nCheck if the given address exists on chain and return the …\nCheck if the given key is present in storage. Returns the …\nWARNING: This only works for values that have been …\nReturns an iterator over the block results\nMutably borrow DB handle\nReturns a value from the specified subspace and the gas …\nReturns a value from the specified subspace at the given …\nDecode the backing store from bytes and tag its type …\nDelete a value at the given key from storage.\nDelete the value corresponding to the given key\nDelete all key-vals with a matching prefix.\nDelete the value with the given height and account …\nThe denomination associated with the above toke\nStatic diff storage key filter\nThe digit position covered by this asset type\nAttempt to downgrade the inner error to <code>E</code> if any.\nReturns some reference to the inner value if it is of type …\nDrop the current transaction’s write log when it’s …\nBorsh Seriliaze the backing stores of our Merkle tree.\nThe number of bytes when this header is encoded\nEpoch of the block\nEpoch of the block\nFrom the start of <code>FinalizeBlock</code> until the end of <code>Commit</code>, …\nThe masp epoch of the asset type\nThe queue of Ethereum events to be processed in order.\nThe queue of Ethereum events to be processed in order.\nThe queue of Ethereum events to be processed in order.\nThe latest block height on Ethereum processed, if the …\nThe latest block height on Ethereum processed, if the …\nThe latest block height on Ethereum processed, if the …\nExecute write batch.\nExecute write batch.\nQueue of expired transactions that need to be …\nReturns the addresses from the key segments\nReturns the first segment of the key, or <code>None</code> if it is …\nThe first block height 1.\nReturn all starting block heights for each successive …\nThe block heights of the first block of each known epoch. …\nFlush data on the memory to persistent them\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the address from the first key segment if it’s …\nTx gas meter\nVP gas meter\nGet the value in the tree\nReturn the segment at the index parameter\nGetting the block epoch. The epoch is that of the block to …\nGetting the block header.\nGet the block header\nGetting the block height. The height is that of the block …\nGet the block height\nGetting the chain ID.\nGet the chain ID as a raw string\nGet the current conversions\nGet the height of the next block\nGet the current (yet to be committed) block epoch\nGet the height of the first block of the current epoch.\nLook up the epoch of a given block height. If the given …\nGiven the epoch at the given block height.\nGet the height of the first block of the given epoch.\nLook up the starting block height of an epoch at or before …\nGet a Tendermint-compatible existence proof.\nGet the height of the last committed block or 0 if no …\nGet the timestamp of the last committed block, or the …\nGet the epoch of the last committed block\nRebuild Merkle tree with diffs in the DB. Base tree and …\nGet the native token address\nGet the non-existence proof\nGet the non-existence proof\nGet the oldest epoch where we can read a value\nGiven the information about predecessor block epochs\nRead the merkle root of the requested type\nLook up the starting block height of the given epoch\nReturns the Merkle root hash and the height of the …\nRead the backing store of the requested type\nGet the existence proof from a sub-tree\nGet the Tendermint proof with the base proof\nGet the transaction index.\nCheck if the given tx hash has already been committed to …\nStorage <code>has_key</code> in. It will try to read from the storage.\nCheck if the given replay protection entry exists\nCheck it the given transaction’s hash is already present …\nCheck if the given tx hash has already been processed\nHash the value to store\nMerkle root hash of block\nHeader of the block\nDuring <code>FinalizeBlock</code>, this is the header of the block that …\nHeight of the block\nHeight of the block\nBlock height\nFrom the start of <code>FinalizeBlock</code> until the end of <code>Commit</code>, …\nA module that contains\nImplement [<code>trait StorageRead</code>] using its [<code>trait StateRead</code>] …\nImplement [<code>trait StorageWrite</code>] using its [<code>trait State</code>] …\nBorrow <code>InMemory</code> state\nBorrow in-memory state\nBorrow in-memory state\nState\nState\nMutably borrow in-memory state\nMutably borrow in-memory state\nInitialize the first epoch. The first epoch begins at …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert a <code>std::result::Result</code> into storage_api <code>Result</code>.\nCheck if the tx at the given position is accepted.\nCheck if we are at a given <code>BlockHeight</code> offset, …\nReturns <code>true</code> if the key is empty\nA full commit is executed only at the first height or one …\nReturns <code>true</code> if a new masp epoch has begun\nReturn true if the subtree should be saved in every block\nCheck if the given key is a key to a validity predicate. …\nGet an iterator for the base tree and subtrees\nThe concrete iterator implementation\nThe concrete iterator implementation\nIterates over all addresses in the key segments\nIterate a range of epochs, inclusive of the start and end.\nRead replay protection storage from the current bucket\nRead subspace new diffs at a given height\nStorage prefix iterator. It will try to read from the …\nGet an iterator for the non-provable subtrees\nRead subspace old diffs at a given height\nWARNING: This only works for values that have been …\nIterate Borsh encoded items matching the given prefix, …\nWARNING: This only works for values that have been …\nStorage prefix iterator ordered by the storage keys. It …\nIterate items matching the given prefix, ordered by the …\nIterate write-log storage items posterior to a tx …\nIterate write-log storage items prior to a tx execution, …\nIterate Borsh encoded items matching the given prefix and …\nGet an iterator for the provable subtrees\nIterate a range of consecutive epochs starting from <code>self</code> …\nReturn an iterator over the removed txs in this …\nRead results subspace key value pairs from the DB\nGet an iterator for subtrees\nReturns a new key with segments of <code>Self</code> and the given key\nReturns the last segment of the key, or <code>None</code> if it is …\nThe most recently committed block, if any.\nThe epoch of the most recently committed block. If it is …\nThe position of this leaf in the conversion tree\nReturns the length\nLoad the full state at the last committed height, if any. …\nFind the root hash of the merkle tree\nMerkle tree stores\nGet an instance of DB migrator\nDB mock for testing\nMove the current replay protection bucket to the general …\nMove the tx hashes from the current bucket to the general …\nConvert from a <code>usize</code> or panic.\nThe address of the native token - this is not stored in …\nRestore the full tree from the stores\nInitialize a new prefix iterator\nInitialize a new prefix iterator\nCreate a new instance of the state\nCreate an <code>Error</code> from another <code>std::error::Error</code>.\nCreate an <code>Error</code> from a heap allocated message.\nCreate an <code>Error</code> from a static message.\nRecord start of a new epoch at the given block height\nRestore the partial tree from the stores without validation\nReturns the next pair and the gas cost\nChange to the next epoch\nMinimum block height at which the next epoch may start\nMinimum block height at which the next epoch may start\nMinimum block height at which the next epoch may start\nMinimum block time at which the next epoch may start\nMinimum block time at which the next epoch may start\nMinimum block time at which the next epoch may start\nGet the height of the next block\nHash of the addresses of the next validator set\nThe last amount of the native token distributed\nTransforms the <code>Option&lt;T&gt;</code> into a <code>Result&lt;T&gt;</code>, mapping [<code>Some(v)</code>…\nOpen the database from provided path\nInstantiate a full-access state. Loads the last state from …\nOverwrite a new value in storage, taking into account …\nReverse of <code>into_string</code>. Convert key segment to <code>Self</code>.\nParses string and returns a key\nReturns a key from the given DB key path that has the …\nGet the path to the db in the filesystem, if it exists …\nThe pattern we are matching keys against.\nPredecessor block epochs\nPredecessor block epochs\nPredecessor block epochs\nThe storage prefix iterators can be used to iterate over a …\nChange to the previous epoch.\nGet the height of the previous block\nGet the key prefix if the store type is for a provable …\nPrune Merkle tree stores at the given epoch\nPrune non-persisted diffs that are only kept for one block …\nReturns a new key with segments of <code>Self</code> and the given …\nConvert <code>Self</code> to a string.\nStorage read Borsh encoded value. It will try to read from …\nRead the block header with the given height from the DB\nRead the signed nonce of Bridge Pool\nStorage read raw bytes. It will try to read from the …\nRead the value for the account diffs at the corresponding …\nRead the last committed block’s metadata\nRead the merkle tree stores with the given epoch. If a …\nBorrow read-only write-log and state\nRead the latest value for account subspace key from the DB\nRead the value for account subspace key at the given …\nMark the provided transaction’s hash as redundant to …\nReject the tx at the given position.\nOverwrite the contents of the current database with the …\nBorrow state with mutable write-log.\nResults of applying transactions\nResults of applying transactions\nResults of applying transactions\nGet the root of the given store type\nGet the root\nChecked epoch subtraction. Computes self - rhs, returning …\nThe segments of the key in the original (left-to-right) …\nA sentinel value block height 0 may be used before any …\nErrors sentinel\nSet the block header. The header is not in the Merkle tree …\nSet the root of the given store type\nSet the store of the given store type\nSplitting borrow to get mutable reference to <code>WriteLog</code>, …\nReturns the prefix before the last segment and last …\nCheck if the key begins with the given prefix and returns:\nPeekable storage iterator\nHow many block heights in the past can the storage be …\nGet the store of the given store type\nGet the stores of the base and sub trees\nThe prefix that is being iterated. This prefix will be …\nGet the store type and the sub key\nReturns a sub key without the first segment\nGet the root of a sub-tree\nTime of the block\nTime of the block\nBlock time\nTimestamp associated to block\nConvert <code>Self</code> to a key segment. This mapping should …\nGet owned copies of backing stores of our Merkle tree.\nThe token associated with this asset type\nQueue of transfer to Namada events.\nMerkle tree of all the other data in block storage\nThe tree currently containing all the conversions\nThe shielded transaction index\nTransaction queue\nUnchecked epoch addition.\nUpdate the tree with the given key and value\nUpdate the commit data subtree\nInitialize a new epoch when the current epoch is finished. …\nUpdate epoch delay\nUpdate epoch delay\nWe delay the switch to a new epoch by the number of blocks …\nUpdate the merkle tree with epoch data\nUpdate the merkle tree written for the committed last block\nUpdate the merkle tree written for the committed last block\nRecalculate the merkle tree root of storage and compare it …\nGet the hash of a validity predicate for the given account …\nReturns a key of the validity predicate of the given …\nReturns a key of the wasm code of the given hash\nReturns a key of the wasm code’s length of the given hash\nReturns a key of wasm code’s hash of the given name\nReturns a key of the wasm code hash of the given code path\nTakes ownership of the key, appends a new segment to it, …\nBorrow in-memory state and DB handle with a mutable …\nBorrow in-memory state and DB handle with a mutable …\nPerforms storage writes at the tx level of the write-log.\nWrap another <code>std::error::Error</code> with a static message.\nAdd a static message to a possible error in <code>Result</code>.\nWrite a value to be encoded with Borsh at the given key to …\nWrite a value as bytes at the given key to storage.\nWrite log is temporary storage for modifications performed …\nBorrow <code>WriteLog</code>\nBorrow write-log\nBorrow write-log\nWrite log\nWrite log\nPeekable write log iterator\nBorrow mutable <code>WriteLog</code>\nMutably borrow write-log\nMutably borrow write-log\nMutably borrow write-log\nWrite a replay protection entry\nWrite the provided tx hash to storage\nWrite the value with the given height and account subspace …\nWrite the provided tx hash to write log.\nA lazy collection of storage values.\nLazy map.\nA lazy set.\nLazy dynamically-sized vector.\nLazy collection with a nested lazy collection\nSimple lazy collection with borsh deserializable elements\nPossible sub-keys in the collection\nA type of a value in the inner-most collection\nGet a nested collection at given key <code>key</code>. If there is no …\nRead the last element\nReturns whether the map contains a key with a value.\nReturns whether the nested map contains a certain key with …\nReturns whether the set contains a value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRead the first element\nReturns the value corresponding to the key, if any.\nRead an element at the index or <code>Ok(None)</code> if out of bounds.\nGet the sub-key of a given element\nGet the storage sub-key of a given raw key\nInserts a key-value pair into the map.\nInserts a key into the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the given storage key is a valid data key.\nReturns whether the map contains no elements.\nReturns whether the map contains no elements.\nReturns whether the set contains no elements.\nReturns <code>true</code> if the vector contains no elements.\nCheck if the given storage key is a valid LazyVec sub-key …\nCheck if the given storage key is a valid LazyVec sub-key …\nAn iterator visiting all key-value elements. The iterator …\nAn iterator visiting all key-value elements, where the …\nAn iterator visiting all keys. The iterator element type …\nAn iterator visiting all elements. The iterator element …\nLazy map.\nLazy set.\nLazy dynamically-sized vector.\nReads the number of elements in the map.\nReads the number of elements in the map.\nReads the number of elements in the vector.\nCreate or use an existing vector with the given storage <code>key</code>…\nCreate or use an existing map with the given storage <code>key</code>.\nCreate or use an existing map with the given storage <code>key</code>.\nCreate or use an existing vector with the given storage <code>key</code>…\nRemoves the last element from a vector and returns it, or …\nAppends an element to the back of a collection.\nRemoves a key from the map if it’s present, returning …\nRemoves a key from the set if it’s present, returning …\nRemove all map entries at a given key prefix\nTries to inserts a key into the set.\nTry update a value at the given key with the given …\nUpdate a value at the given key with the given function. …\nUpdate an element at the given index.\nTrait used to facilitate collection of lazy maps into …\nThe type of the value of the lazy map\nSubkey corresponding to the data elements of the LazyMap\nData sub-key, further sub-keyed by its literal map key\nData sub-key\nLazy map.\nA <code>LazyMap</code> with another <code>LazyCollection</code> inside it’s value <code>V</code>\nPossible sub-keys of a nested <code>LazyMap</code>\nPossible sub-keys of a <code>LazyMap</code>\nCollect the lazy map into an eager map\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLiteral map key\nSub-key in the nested collection\nLiteral set key\nA lazy set.\nPossible sub-keys of a <code>LazySet</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSubkey corresponding to the data elements of the LazyVec\nData sub-key, further sub-keyed by its index\nUsing <code>u64</code> for vector’s indices\nSubkey pointing to the length of the LazyVec\nLazy dynamically-sized vector.\nLength sub-key\nPossible sub-keys of a <code>LazyVec</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the leaf spec for the base tree. The key is stored …\nGet the leaf spec for the ibc subtree.\nGet the proof specs for ibc\nGet the leaf spec for the subtree. Non-hashed values are …\nGet the proof specs\nAn in-memory DB for testing.\nSource to restore a <code>MockDB</code> from.\nAn in-memory write batch is not needed as it just updates …\nA prefix iterator base for the <code>MockPrefixIterator</code>.\nMockDB pattern iterator\nA prefix iterator for the <code>MockDB</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe concrete iterator implementation\nThe concrete iterator\nReturns the next pair and the gas cost\nThe prefix that is being iterated. This prefix will be …\nA prefix iterator identifier for the temporary storage …\nA temporary iterators storage, used during a wasm run …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet prefix iterator with the given ID.\nGet the ID as <code>u64</code>.\nInsert a new prefix iterator to the temporary storage. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitialize a new ID.\nGet the next item in the given prefix iterator.\nAn Ethereum event to be processed by the Namada ledger\nBroadcast the given Ethereum event.\nExpired transaction kinds.\nQueue of expired transactions that need to be …\nA confirmation event that a batch of transfers have been …\nEvent transferring batches of ether or Ethereum based …\nEvent indication that the validator set has been updated …\nConsume all the transactions in the queue.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSHA256 of the Borsh serialization of the <code>EthereumEvent</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPush a new transaction to the back of the queue.\nHash of the validators in the bridge contract\nHash of the validators in the governance contract\nMonotonically increasing nonce\nMonotonically increasing nonce\nMonotonically increasing nonce\nThe Namada address that receives the gas fees for relaying …\nThe batch of transfers\nThe batch of transfers\nDelete an existing key-value\nContains the error value\nInitialize a new account with established address and a …\nContains the success value\nWrite log prefix iterator\nResult for functions that may fail\nA storage modification\nWrite a new value\nThe write log storage\nCommit the current tx and the entire batch to the block …\nCommit the entire batch to the block log. Doesn’t handle …\nCommit the current transaction’s write log to the batch …\nDelete a key and its value, and return the gas cost and …\nDrop the current tx and the entire batch log.\nDrop the current transaction’s write log and IBC events …\nSet an event and return the gas cost. Returns <code>None</code> on gas …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet all events emitted by the current transaction.\nGet events emitted by the current transaction of type <code>E</code>.\nGet the addresses of accounts initialized in the current …\nGet the non-temporary storage keys changed and accounts …\nGet the storage keys changed in the current transaction …\nCheck if the given tx hash has already been processed\nInitialize a new account and return the gas cost.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe concrete iterator for modifications sorted by storage …\nIterate modifications posterior of the current tx, whose …\nIterate modifications prior to the current transaction, …\nGet events emitted by the current transaction of a certain …\nDelete a key and its value. Fails with <code>Error::DeleteVp</code> for …\nWrite a key and a value. Fails with …\nRead a non-temp value at the given key and return the …\nRead a value before the latest tx execution at the given …\nRead a temp value at the given key and return the value …\nTake the events of the current transaction\nGet the verifiers set whose validity predicates should …\nWrite a key and a value and return the gas cost and the …\nWrite a key and a value and return the gas cost and the …\nWrite the transaction hash\nValue bytes\nValidity predicate hash bytes")