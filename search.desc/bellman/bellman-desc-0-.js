searchState.loadedDescShard("bellman", 0, "<code>bellman</code> is a crate for building zk-SNARK circuits. It …\nDuring synthesis, we lacked knowledge of a variable …\nComputations are expressed in terms of arithmetic …\nRepresents a constraint system which can have new variables\nDuring synthesis, we divided by zero.\nRepresents the index of either an input variable or …\nProof verification failed.\nVerification was attempted with a malformed verifying key.\nDuring proof generation, we encountered an I/O error with …\nThis represents a linear combination of some variables, …\nThis is a “namespaced” constraint system which borrows …\nDuring synthesis, our polynomials ended up being too high …\nRepresents the type of the “root” of this constraint …\nThis is an error that could occur during circuit synthesis …\nDuring CRS generation, we observed an unconstrained …\nDuring proof generation, we encountered an identity in the …\nDuring synthesis, we constructed an unsatisfiable …\nRepresents a variable in our constraint system.\nAn error during verification.\nAllocate a private variable in the constraint system. The …\nAllocate a public variable in the constraint system. The …\nThis module contains an <code>EvaluationDomain</code> abstraction for …\nEnforce that <code>A</code> * <code>B</code> = <code>C</code>. The <code>annotation</code> function is invoked …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSelf-contained sub-circuit implementations for various …\nGets the “root” constraint system, bypassing the …\nThis returns the index underlying the variable. Circuit …\nThe Groth16 proving system.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn interface for dealing with the kinds of parallel …\nBegin a namespace for this constraint system.\nThis constructs a variable with an arbitrary index. …\nReturn the “one” input variable\nExit out of the existing namespace. Not intended for …\nCreate a new (sub)namespace and enter into it. Not intended\nSynthesize the circuit into a rank-1 quadratic constraint …\nThe target polynomial is the zero polynomial in our …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPerform O(n) multiplication of two polynomials in the …\nPerform O(n) subtraction of one polynomial from another in …\nThis evaluates t(tau) for this domain, which is tau^m - 1 …\nThis basically is just an extension to <code>Option</code> which allows …\nThe BLAKE2s hash function with personalization support.\nGadgets for allocating bits in the circuit and performing …\nWindow table lookup gadgets.\nHelpers for packing vectors of bits into scalar field …\nGadgets representing numbers in the scalar field of the …\nCircuits for the SHA-256 hash function and its internal …\nHelpers for testing circuit implementations.\nCircuit representation of a <code>u32</code>, with helpers for the …\nRepresents a variable in the constraint system which is …\nThis is a boolean value which may be either a constant or …\nConstant (not an allocated variable)\nExistential view of the boolean variable\nNegated view of the boolean variable\nAllocate a variable in the constraint system which can …\nAllocate a variable in the constraint system which can …\nPerforms an AND operation over the two operands, returning …\nPerform AND over two boolean operands\nCalculates <code>a AND (NOT b)</code>.\nConstruct a boolean from a known constant\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalculates <code>(NOT a) AND (NOT b)</code>.\nReturn a negated interpretation of this boolean.\nComputes (a and b) xor ((not a) and c)\nComputes (a and b) xor (a and c) xor (b and c)\nPerforms an XOR operation over the two operands, returning …\nPerform XOR over two boolean operands\nPerforms a 3-bit window table lookup. <code>bits</code> is in …\nPerforms a 3-bit window table lookup, where one of the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTakes a sequence of booleans and exposes them as compact …\nTakes two allocated numbers (a, b) and returns (b, a) if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the allocated number into its little-endian …\nDeconstructs this allocated number into its boolean …\nConstraint system for testing purposes.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRepresents an interpretation of 32 <code>Boolean</code> objects as an …\nPerform modular addition of several <code>UInt32</code> objects.\nAllocate a <code>UInt32</code> in the constraint system\nConstruct a constant <code>UInt32</code> from a <code>u32</code>\nReturns the argument unchanged.\nConverts a little-endian byte order representation of bits …\nCalls <code>U::from(self)</code>.\nTurns this <code>UInt32</code> into its little-endian byte order …\nCompute the <code>ch</code> value <code>(a and b) xor ((not a) and c)</code> during …\nCompute the <code>maj</code> value (a and b) xor (a and c) xor (b and c)\nXOR this <code>UInt32</code> with another <code>UInt32</code>\nPerforms batch Groth16 proof verification.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate parameters for a circuit, given some toxic waste.\nGenerates a random common reference string for a circuit.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA batch verification item.\nA batch verification context.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new batch verifier.\nQueue a (proof, inputs) tuple for verification.\nPerform batch verification with a particular <code>VerifyingKey</code>, …\nPerform non-batched verification of this <code>Item</code>.\nOne-off sending.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes this waiter and blocks until the result is ready.\nAn exponent\nReturns whether the base exists.\nA source of bases, like an iterator.\nAn object that builds a source of bases.\nParses the element from the source. Fails if the point is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPerform multi-exponentiation. The caller is responsible …\nSkips <code>amt</code> elements from the source, avoiding …")