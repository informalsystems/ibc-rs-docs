searchState.loadedDescShard("namada_sdk", 3, "Returns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA signed 256 big integer.\nA positive or negative amount\nMaximum value.\nThe maximum absolute value a <code>I256</code> may have. Note the last …\nThe maximum 256 bit integer\nThe value one.\nLittle-endian large integer type Namada native type to …\nThe value zero.\nGet the absolute value\nComputes the absolute difference between self and other.\nConversion to u128 with overflow checking\nConversion to u32 with overflow checking\nConversion to u64 with overflow checking\nConversion to usize with overflow checking\nReturn if specific bit is set.\nReturn the least number of bits needed to represent the …\nReturn the least number of bits needed to represent the …\nReturn specific byte.\nGet the absolute value\nChecked addition. Returns <code>None</code> if overflow occurred.\nAdds two <code>I256</code>’s if the absolute value does not exceed …\nChecked division. Returns <code>None</code> if <code>other == 0</code>.\nChecked division\nChecked multiplication. Returns <code>None</code> if overflow occurred.\nChecked multiplication\nReturns a pair …\nChecked negation. Returns <code>None</code> unless <code>self == 0</code>.\nChecked negation\nChecked exponentiation. Returns <code>None</code> if overflow occurred.\nChecked modulus. Returns <code>None</code> if <code>other == 0</code>.\nChecked division remnant\nChecked subtraction. Returns <code>None</code> if overflow occurred.\nSubtracts two <code>I256</code>’s if the absolute value does not …\nReturns a pair <code>(self / other, self % other)</code>.\nReturns a pair <code>(self / other, self % other)</code>.\nCreate <code>10**n</code> as this type.\nDivide two <code>Uint</code>s with scaled to allow the <code>denom</code> number of …\nReturn the ceiling of the product of an integer and a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts from big endian representation bytes in memory.\nConvert from a decimal string.\nConverts from little endian representation bytes in memory.\nGiven an i128 and <code>MaspDigitPos</code>, construct the corresponding\nGiven a u128 and <code>MaspDigitPos</code>, construct the corresponding …\nConverts a string slice in a given base to an integer. …\nConvert a <code>u64</code> to a <code>Uint</code>.\nCompute the highest <code>n</code> such that <code>n * n &lt;= self</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the amount is negative (less than zero)\nCheck if the amount is negative (less than zero)\nCheck if the amount is positive (greater than zero)\nCheck if the amount is positive (greater than zero)\nWhether this is zero.\nCheck if this value is zero\nReturns the number of leading zeros in the binary …\nLow 2 words (u128)\nConversion to u32\nLow word (u64)\nThe maximum value which can be inhabited by this type.\nThe maximum value of an <code>I256</code>.\nMultiply by a decimal <code>Dec</code> with the result rounded up. …\nCompute the two’s complement of a number.\nCheck if the amount is not negative (greater than or equal …\nOne (multiplicative identity) of this type.\nGives the one value of an I256\nGives the one value of an SignedAmount\nAddition which overflows and returns a flag if it does.\nMultiply with overflow, returning a flag if it does.\nNegation with overflow.\nCompute the negation of a number.\nFast exponentiation by squaring. Returns result and …\nSubtraction which underflows and returns a flag if it does.\nFast exponentiation by squaring …\nAddition which saturates at the maximum value (Self::MAX).\nMultiplication which saturates at the maximum value..\nSubtraction which saturates at zero.\nSum with overflow check\nWrite to the slice in big-endian format.\nWrite to the slice in little-endian format.\nGet a string representation of <code>self</code> as a native token …\nGet a string representation of <code>self</code> as a native token …\nReturns the number of trailing zeros in the binary …\nZero (additive identity) of this type.\nGives the zero value of an I256\nError result returned by validity predicates.\nHelper trait for converting between result types.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConvert to a <code>Result</code> with <code>VpError</code> errors.\nNamada voting power, normalized to the range <code>0 - 2^32</code>.\nA fraction of the total voting power. This should always …\nHalf of the voting power.\nMaximum value that can be represented for the voting power …\nNull voting power.\nOne third of the voting power.\nTwo thirds of the voting power.\n100% of the voting power.\nMultiple with overflow checks.\nMultiply by <code>token::Amount</code> with overflow checks\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>FractionalVotingPower</code>. It must be between …\nCreate a new <code>FractionalVotingPower</code>, from a <code>u64</code> numerator …")