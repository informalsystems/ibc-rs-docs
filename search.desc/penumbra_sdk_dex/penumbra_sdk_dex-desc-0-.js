searchState.loadedDescShard("penumbra_sdk_dex", 0, "The configuration parameters for the DEX component.\nA directed tuple of <code>Unit</code>s, similar to a <code>DirectedTradingPair</code>…\nContains the summary data of a trade, for client …\nThe canonical representation of a tuple of asset [<code>Id</code>]s.\nRepresents a trading pair in R1CS.\nThe last observed price during the block execution.\nThe total amount of asset 1 that was input to the batch …\nThe total amount of asset 2 that was input to the batch …\nThe volume that traded “directly”, during individual …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTakes an input of the form DENOM1:DENOM2, splits on the <code>:</code> …\nTakes an input of the form DENOM1:DENOM2, splits on the <code>:</code> …\nTakes an input of the form DENOM1:DENOM2, splits on the <code>:</code> …\nThe height for which the batch swap data is valid.\nThe block height of the candlestick data.\nThe highest observed price during the block execution.\nThe input value that was consumed.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe total amount of asset 1 that was output from the batch …\nThe total amount of asset 2 that was output from the batch …\nThe lowest observed price during the block execution.\nReturns the price of the latest execution trace.\nThis allocates a <code>TradingPairVar</code> without checking it is …\nThe first observed price during the block execution.\nThe output value that was produced.\nGiven a user’s inputs <code>(delta_1_i, delta_2_i)</code>, compute …\nThe position prefix where this batch swap occurred. The …\nThe volume that traded as part of swaps, which could have …\nThe trading pair associated with the batch swap.\nThe amount of asset 1 that was returned unfilled from the …\nThe amount of asset 2 that was returned unfilled from the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate this event using the usual context available to us.\nCreate this event using the usual context available to us.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe initial configuration parameters for the DEX component.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe data describing a trading function.\nHelper structure for constructing a <code>Position</code> expressing …\nThe denomination of an LPNFT tracking both ownership and …\nThe reserves of a position.\nHelper structure for constructing a <code>Position</code> expressing …\nAugment <code>self</code> with type information to get a typed <code>Balance</code>.\nCompose two trading functions together\nConverts an amount of <code>lambda_2</code> into <code>delta_1</code>, using the …\nConverts an amount <code>delta_1</code> into <code>lambda_2</code>, using the …\nReturns the exchange rate from <code>asset_2</code> to …\nReturns the inverse of the <code>effective_price</code>, in other words,\nReturns a byte key for this trading function with the …\nThe fee, expressed in basis points.\nFills a trade of an input value against this position, …\nFills a trade of asset 1 to asset 2 against the given …\nAttempts to compute the input value required to produce …\nDetermine the amount of asset 1 that can be filled for a …\nFlip the reserves\nFormats this <code>BuyOrder</code> as a string.\nFormats this <code>SellOrder</code> as a string.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>gamma</code> i.e. the fee percentage. The fee is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks that the specified input’s asset type matches …\nThe valuation for the first asset of the pair, according …\nEventually we’ll need to plumb in an asset::Cache so …\nEventually we’ll need to plumb in an asset::Cache so …\nReturns a formatted representation of the price component. …\nReturns a formatted representation of the price component. …\nThe valuation for the second asset of the pair, according …\nReturn zero reserves.\nA transaction action that closes a position.\nA transaction action that opens a new position.\nA transaction action that withdraws funds from a closed …\nCompute a commitment to the value this action contributes …\nCompute the value this action contributes to its …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains the data defining the position, sufficient to …\nA transparent (zero blinding factor) commitment to the …\nThe sequence number of the withdrawal, allowing multiple …\nA planned <code>PositionWithdraw</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConvenience method to construct the <code>PositionWithdraw</code> …\nThe position has been closed, is inactive and can no …\nA hash of a <code>Position</code>.\nA trading function’s fee (spread) must be at most 50% …\nReserve amounts for positions must be at most 80 bits wide.\nThe position has been opened, is active, has reserves and …\nEncapsulates the immutable parts of the position …\nThe state of a position.\nThe final reserves and accumulated fees have been …\nSet to <code>true</code> if a position is a limit-order, meaning that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the ID of this position.\nAttempts to interpret this position as a “buy order”.\nInterprets a position with mixed reserves as a pair of “…\nAttempts to interpret this position as a “sell order”.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new opened Position with a random nonce.\nConstruct a new opened Position with a supplied random …\nA random value used to disambiguate different positions …\nA trading function to a specific trading pair.\nReturns the amount of reserves for asset 1.\nReturns the amount of reserves for asset 2.\nReturns the amount of the given asset that is currently in …\nThe sequence number, incrementing with each withdrawal.\nLooks up a <code>Position</code> by its ID\nA planned <code>Swap</code>.\nTemporary method until we resolve where …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>SwapPlan</code> that requests a swap between the …\nConvenience method to construct the <code>Swap</code> described by this …\nConstruct the <code>swap::Body</code> described by this <code>SwapPlan</code>.\nConstruct the <code>SwapProof</code> required by the <code>swap::Body</code> …\nThe private inputs to a <code>SwapProof</code>.\nThe public inputs to a <code>SwapProof</code>.\nA commitment to the balance of this transaction.\nA randomizer to make the commitment to the fee hiding.\nA commitment to the fee that was paid.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA commitment to the swap.\nAll information about the swap.\nCalled to verify the proof using the provided public …\nA planned <code>SwapClaim</code>.\nCompute a commitment to the value contributed to a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether this plan’s output is viewed by the given …\nThe first blinding factor used for generating the ZK proof.\nThe second blinding factor used for generating the ZK …\nConvenience method to construct the <code>SwapClaim</code> described by …\nConstruct the <code>swap_claim::Body</code> described by this plan.\nConstruct the <code>SwapClaimProof</code> required by the …\nSwapClaim consumes an existing Swap so they are most …\nThe public inputs to a [<code>SwapProofPrivate</code>].\nThe public inputs to a [<code>SwapProofPublic</code>].\nThe spend verification key\nAnchor\nFee\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOutput amount 1\nOutput amount 2\nNote commitment blinding factor for the first output note\nNote commitment blinding factor for the second output note\nNote commitment of first output note\nNote commitment of second output note\nNullifier\nBatch swap output data\nGenerate an <code>SwapClaimProof</code> given the proving key, public …\nInclusion proof for the swap commitment\nThe swap being claimed\nCalled to verify the proof using the provided public …")