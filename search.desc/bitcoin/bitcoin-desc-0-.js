searchState.loadedDescShard("bitcoin", 0, "Rust Bitcoin Library\n0x1: Sign all outputs.\n0x1: Sign all outputs.\n0x81: Sign all outputs but only this input.\n0x81: Sign all outputs but only this input.\n0x0: Used when not explicitly specified, defaults to …\nHashtype of an input’s signature, encoded in the last …\nHash of a transaction according to the legacy signature …\n0x2: Sign no outputs — anyone can choose the destination.\n0x2: Sign no outputs — anyone can choose the destination.\n0x82: Sign no outputs and only this input.\n0x82: Sign no outputs and only this input.\nA Bitcoin ECDSA private key\nA hash of a public key.\nA Bitcoin ECDSA public key\nHash of a transaction according to the segwit version 0 …\n0x3: Sign the output whose index matches this input’s …\n0x3: Sign the output whose index matches this input’s …\n0x83: Sign one output and only this input (see <code>Single</code> for …\n0x83: Sign one output and only this input (see <code>Single</code> for …\nTaproot-tagged hash with tag &quot;TapSighash&quot;.\nThe tag used for <code>TapSighash</code>\nHashtype of an input’s signature, encoded in the last …\nSegWit version of a public key hash.\nAn x-only public key, used for verification of Taproot …\nTweaks an <code>XOnlyPublicKey</code> by adding the generator …\nBitcoin addresses.\nBitcoin amounts.\nObtains a raw mutable pointer suitable for use with FFI …\nObtains a raw const pointer suitable for use with FFI …\nBase58 encoder and decoder.\nEncodes and decodes the Bech32 forrmat.\nBIP152 Compact Blocks\nBIP 158 Compact Block Filters for Light Clients.\nBIP32 implementation.\nBitcoin block data.\nLike <code>cmp::Cmp</code> but faster and with no guarantees across …\nWhether this public key should be serialized as compressed\nWhether this private key should be serialized as compressed\nBitcoin consensus.\nECDSA Bitcoin signatures.\nLike <code>cmp::Eq</code> but faster and with no guarantees across …\nContains error types and other error handling tools.\nReturns the argument unchanged.\nReturns the <code>XOnlyPublicKey</code> (and it’s <code>Parity</code>) for <code>keypair</code>.\nCreates a schnorr public key directly from a slice.\nBitcoin hash types.\nRust implementation of cryptographic hash function …\nRe-export the <code>hex-conservative</code> crate.\nThe actual ECDSA key\nThe actual ECDSA key\nCalls <code>U::from(self)</code>.\nBitcoin keys.\nBitcoin merkle tree functions.\nBitcoin network.\nThe network on which this key should be used\nBitcoin p2p network types.\nBitcoin policy.\nProof-of-work related integer types.\nPartially Signed Bitcoin Transactions.\nReturns the <code>PublicKey</code> for this <code>XOnlyPublicKey</code>.\nRust wrapper library for Pieter Wuille’s libsecp256k1.  …\nSerializes the key as a byte-encoded x coordinate value …\nSignature hash implementation (used in transaction …\nSignature\nBitcoin string parsing utilities.\nBitcoin Taproot.\nVerifies that a tweak produced by <code>XOnlyPublicKey::add_tweak</code>…\nChecks that <code>sig</code> is a valid schnorr signature for <code>msg</code> using …\nA Bitcoin address.\nA utility struct to encode an address payload with the …\nThe different types of addresses.\nIndicates whether this <code>NetworkValidation</code> is <code>NetworkChecked</code> …\nMarker that address’s network has been successfully …\nMarker that address’s network has not yet been …\nMarker of status of address’s network validation. See …\nPay to pubkey hash.\nPay to script hash.\nPay to taproot.\nPay to witness pubkey hash.\nPay to witness script hash.\nThe method used to produce an address.\nP2PKH address.\nP2SH address.\nSegwit address.\nGets the address type of the address.\nReturns a reference to the unchecked address, which is …\nMarks, without any additional checks, network of this …\nReturns a reference to the checked address. This function …\nError code for the address module.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a Payload from an output script (<code>scriptPubkey</code>).\nConstructs an <code>Address</code> from an output script (<code>scriptPubkey</code>).\nThe bech32 human-readable part.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtracts and returns the network and payload components of …\nReturns true if the given pubkey is directly related to …\nReturns true if the supplied xonly public key can be used …\nChecks whether or not the address is following Bitcoin …\nParsed addresses do not always have <em>one</em> network. The …\nReturns true if the address creates a particular script …\nReturns true if the address creates a particular script …\nReturns a reference to the network of this address.\nCreate new address from given components, infering the …\nCreates a pay to (compressed) public key hash payload from …\nCreates a pay to (compressed) public key hash address from …\nbase58 version byte for p2pkh payloads (e.g. 0x00 for “1…\nCreates a pay to script hash P2SH payload from a script\nCreates a pay to script hash P2SH address from a script.\nbase58 version byte for p2sh payloads (e.g. 0x05 for “3…\nCreate a pay to script payload that embeds a witness pay …\nCreates a pay to script address that embeds a witness pay …\nCreate a pay to script payload that embeds a witness pay …\nCreates a pay to script address that embeds a witness pay …\nCreate a pay to taproot payload from untweaked key\nCreates a pay to taproot address from an untweaked key.\nCreate a pay to taproot payload from a pre-tweaked output …\nCreates a pay to taproot address from a pre-tweaked output …\nCreate a witness pay to public key payload from a public …\nCreates a witness pay to public key address from a public …\nCreate a witness pay to script hash payload.\nCreates a witness pay to script hash address.\nReturns a reference to the payload of this address.\nThe address payload to encode.\nChecks whether network of this address is as required.\nGenerates a script pubkey spending to this Payload.\nGenerates a script pubkey spending to this address.\nCreates a URI string <em>bitcoin:address</em> optimized to be …\nBase58 error.\nBech32 segwit decoding error.\nAddress error.\nAddress size more than 520 bytes is not allowed.\nAddress’s network differs from required one.\nAddress parsing error.\nAn uncompressed pubkey was used where it is not allowed.\nAddress type is either invalid or not supported in …\nScript is not a p2pkh, p2sh or witness program.\nA witness program error.\nA witness program error.\nA witness version construction error.\nA witness version conversion/parsing error.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe address itself\nNetwork on which the address was found to be valid.\nNetwork that was required.\nAmount\nbits\nBTC\ncBTC\nCalculate the sum over the iterator using checked …\nA set of denominations in which amounts can be expressed.\nA helper/builder that displays amount with specified …\nInput string was too large.\nInvalid character in input.\nInvalid number format.\nThe maximum value of an amount.\nThe maximum value of an amount.\nThe maximum value allowed as an amount. Useful for sanity …\nThe maximum value allowed as an amount. Useful for sanity …\nThe minimum value of an amount.\nThe minimum value of an amount.\nuBTC\nmBTC\nmsat\nnBTC\nAmount is negative.\nExactly one bitcoin.\nExactly one bitcoin.\nExactly one satoshi.\nExactly one satoshi.\nAn error during amount parsing.\npBTC\nThe denomination has multiple possible interpretations.\nThe number of bytes that an amount contributes to the size …\nsatoshi\nSignedAmount\nAmount is too big to fit inside the type.\nAmount has higher precision than supported by the type.\nThe denomination was unknown.\nThe zero amount.\nThe zero amount.\nGet the absolute value of this SignedAmount.\nGet the absolute value of this SignedAmount. Returns None …\nChecked addition. Returns None if overflow occurred.\nChecked addition. Returns None if overflow occurred.\nChecked integer division. Be aware that integer division …\nChecked integer division. Be aware that integer division …\nChecked multiplication. Returns None if overflow occurred.\nChecked multiplication. Returns None if overflow occurred.\nChecked remainder. Returns None if overflow occurred.\nChecked remainder. Returns None if overflow occurred.\nChecked subtraction. Returns None if overflow occurred.\nChecked subtraction. Returns None if overflow occurred.\nCalculate the sum over the iterator using checked …\nCreate an object that implements <code>fmt::Display</code> dynamically …\nCreate an object that implements <code>fmt::Display</code> dynamically …\nCreate an object that implements <code>fmt::Display</code> using …\nCreate an object that implements <code>fmt::Display</code> using …\nFormat the value of this Amount in the given denomination.\nFormat the value of this SignedAmount in the given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a value expressing bitcoins to an Amount.\nConvert from a value expressing bitcoins to an SignedAmount…\nConvert this Amount in floating-point notation with a given\nConvert this SignedAmount in floating-point notation with …\nConvert from a value expressing integer values of bitcoins …\nCreate an Amount with satoshi precision and the given …\nCreate an SignedAmount with satoshi precision and the …\nConvert from a str to Denomination.\nParse a decimal string as a value in the given …\nParse a decimal string as a value in the given …\nParses amounts with denomination suffix like they are …\nParses amounts with denomination suffix like they are …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if this SignedAmount is negative and <code>false</code> if …\nReturns <code>true</code> if this SignedAmount is positive and <code>false</code> if …\nThe maximum value of an Amount.\nThe maximum value of an SignedAmount.\nThe minimum value of an Amount.\nThe minimum value of an SignedAmount.\nSubtraction that doesn’t allow negative SignedAmounts. …\nThis module adds serde serialization and deserialization …\nMakes subsequent calls to <code>Display::fmt</code> display …\nReturns a number representing sign of this SignedAmount.\nExpress this <code>Amount</code> as a floating-point value in Bitcoin.\nExpress this <code>SignedAmount</code> as a floating-point value in …\nExpress this Amount as a floating-point value in the given …\nExpress this SignedAmount as a floating-point value in the …\nGets the number of satoshis in this <code>Amount</code>.\nGets the number of satoshis in this <code>SignedAmount</code>.\nConvert to a signed amount.\nGet a string number of this Amount in the given …\nGet a string number of this SignedAmount in the given …\nGet a formatted string of this Amount in the given …\nGet a formatted string of this SignedAmount in the given …\nConvert to an unsigned amount.\nThis trait is used only to avoid code duplication and …\nThis trait is only for internal Amount type …\nSerialize and deserialize <code>Amount</code> as JSON numbers …\nSerialize and deserialize <code>Amount</code> as real numbers …\nSerialize and deserialize <code>Option&lt;Amount&gt;</code> as JSON numbers …\nSerialize and deserialize <code>Option&lt;Amount&gt;</code> as real numbers …\nInvalid character encountered.\nChecksum was not correct (expected, actual).\nAn error that might occur during base58 decoding.\nAddress version byte were not recognized.\nExtended Key version byte(s) were not recognized.\nThe length (in bytes) of the object was not correct.\nChecked data was less than 4 bytes.\nDecodes a base58-encoded string into a byte vector.\nDecodes a base58check-encoded string into a byte vector …\nEncodes <code>data</code> as a base58 string (see also …\nEncodes <code>data</code> as a base58 string including the checksum.\nEncodes a slice as base58, including the checksum, into a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA BlockTransactions structure is used to provide some of …\nA BlockTransactionsRequest structure is used to list …\nA BIP-152 error\nA HeaderAndShortIds structure is used to relay a block …\nThe prefill slice provided was invalid.\nA PrefilledTransaction structure is used in …\nShort transaction IDs are used to represent a transaction …\nA transaction index is requested that is out of range from …\nAn unknown version number was used.\nReturns a reference the underlying bytes.\nConverts the object to a mutable raw pointer.\nConverts the object to a raw pointer.\nThe blockhash of the block which the transactions being …\nThe blockhash of the block which the transactions being …\nCalculate the SipHash24 keys used to calculate short IDs.\nPanics\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new HeaderAndShortIds from a full block.\nConstruct a BlockTransactions from a …\nThe header of the block being provided.\nThe index of the transaction in the block.\nThe indexes of the transactions being requested in the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the object, as an array, is empty. Always …\nReturns the length of the object as an array.\nA nonce for use in short transaction ID calculations.\nUsed to provide the coinbase transaction and a select few …\nThe short transaction IDs calculated from the transactions …\nReturns the underlying bytes.\nThe transactions provided.\nThe actual transaction.\nCalculate the short ID with the given (w)txid and using …\nBitwise stream reader.\nBitwise stream writer.\nA block filter, as described by BIP 158.\nReads and interprets a block filter.\nCompiles and writes a block filter.\nErrors for blockfilter.\nGolomb-Rice encoded filter reader.\nGolomb-Rice encoded filter writer.\nIO error reading or writing binary serialization of the …\nMissing UTXO, cannot calculate script filter.\nAdds an arbitrary element to filter.\nAdds data to the filter.\nAdds consumed output scripts of a block to filter.\nAdds output scripts of the block to filter (excluding …\nGolomb encoded filter\nComputes this filter’s ID in a chain of filters (see BIP …\nWrites the block filter.\nWrites the filter to the wrapped writer.\nflush bits not yet written.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if all queries match against this …\nReturns true if all queries match against this …\nReturns true if all queries match against this <code>BlockFilter</code>.\nReturns true if any query matches against this …\nReturns true if any query matches against this …\nReturns true if any query matches against this <code>BlockFilter</code>.\nCreates a new <code>BlockFilterWriter</code> from <code>block</code>.\nCreates a new <code>BlockFilterReader</code> from <code>block_hash</code>.\nCreates a new <code>GcsFilterReader</code> with specific seed to …\nCreates a new <code>GcsFilterWriter</code> wrapping a generic writer, …\nCreates a new <code>BitStreamReader</code> that reads bitwise from a …\nCreates a new <code>BitStreamWriter</code> that writes bitwise to a …\nCreates a new filter from pre-computed data.\nComputes a SCRIPT_FILTER that contains spent and output …\nReads nbit bits, returning the bits in a <code>u64</code> starting with …\nWrites nbits bits from data.\nBase58 encoding error\nA pk-&gt;pk derivation was attempted on a hardened key\nA chain code\nA child number for a derived key\nA BIP-32 derivation path.\nAn iterator over children of a DerivationPath.\nA BIP32 error\nThe old name for xpriv, extended public key.\nThe old name for xpub, extended public key.\nA fingerprint\nHardened key\nHexadecimal decoding error\nTrait that allows possibly failable conversion from a type …\nA child number was provided that was out of range\nInvalid childnumber format.\nInvalid derivation path format.\n<code>PublicKey</code> hex should be 66 or 130 digits long.\nFull information on the used extended public key: …\nNon-hardened key\nA secp256k1 error occurred\nUnknown version magic bytes\nEncoded extended key data has wrong length\nExtended key identifier as defined in BIP-32.\nExtended private key\nExtended public key\nXpubIdentifier as defined in BIP-32.\nReturns a reference the underlying bytes.\nReturns a reference the underlying bytes.\nConverts the object to a mutable raw pointer.\nConverts the object to a mutable raw pointer.\nConverts the object to a raw pointer.\nConverts the object to a raw pointer.\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nChain code\nChain code\nChain code\nChain code\nCreate a new DerivationPath that is a child of this one.\nChild number of the key used to derive from parent (0 for …\nChild number of the key used to derive from parent (0 for …\nChild number of the key used to derive from parent (0 for …\nChild number of the key used to derive from parent (0 for …\nGet an Iterator over the children of this DerivationPath …\nPublic-&gt;Public child key derivation\nCompute the scalar tweak added to this key to get a child …\nDecoding extended private key from binary data according …\nDecoding extended public key from binary data according to …\nHow many derivations this key is from the master (which is …\nHow many derivations this key is from the master (which is …\nHow many derivations this key is from the master (which is …\nHow many derivations this key is from the master (which is …\nAttempts to derive an extended private key from a path.\nAttempts to derive an extended public key from a path.\nExtended private key binary encoding according to BIP 32\nExtended public key binary encoding according to BIP 32\nConcatenate <code>self</code> with <code>path</code> and return the resulting new …\nReturns the first four bytes of the identifier\nReturns the first four bytes of the identifier\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>Hardened</code> from an index, returns an error if the …\nCreate a <code>Normal</code> from an index, returns an error if the …\nDerives a public key from a private key\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nGet an Iterator over the hardened children of this …\nReturns the HASH160 of the public key belonging to the …\nReturns the HASH160 of the chaincode\nReturns the child number that is a single increment from …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into a DerivationPath that is a child of this one.\nConvers a given type into a <code>DerivationPath</code> with possible …\nReturns whether the object, as an array, is empty. Always …\nReturns whether the object, as an array, is empty. Always …\nReturns <code>true</code> if the derivation path is empty\nReturns <code>true</code> if the child number is a <code>Hardened</code> value.\nReturns whether derivation path represents master key …\nReturns <code>true</code> if the child number is a <code>Normal</code> value.\nReturns the length of the object as an array.\nReturns the length of the object as an array.\nReturns length of the derivation path\nReturns derivation path for a master key (i.e. empty …\nThe network this key is to be used on\nThe network this key is to be used on\nThe network this key is to be used on\nThe network this key is to be used on\nConstruct a new master key from a seed value\nGet an Iterator over the unhardened children of this …\nFingerprint of the parent key\nFingerprint of the parent key (0 for master)\nFingerprint of the parent key (0 for master)\nFingerprint of the parent key\nPrivate key\nPrivate key\nPublic key\nPublic key\nStart a new DerivationPathIterator at the given child.\nReturns the underlying bytes.\nReturns the underlying bytes.\nConstructs BIP340 keypair for Schnorr signatures and …\nConstructs ECDSA compressed private key matching internal …\nConstructs ECDSA compressed public key matching internal …\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nReturns the derivation path as a vector of u32 integers. …\nConstructs BIP340 x-only public key for BIP-340 signatures …\nKey index, within [0, 2^31 - 1]\nKey index, within [0, 2^31 - 1]\nBitcoin blocks.\nBlockdata constants.\nImplements <code>FeeRate</code> and assoctiated features.\nProvides absolute and relative locktimes.\nBitcoin script opcodes.\nBitcoin scripts.\nBitcoin transactions.\nImplements <code>Weight</code> and associated features.\nWitness\nThe header hash is not below the target.\nThe <code>target</code> field of a block header did not match the …\nAn error when looking up a BIP34 block height.\nBitcoin block.\nBitcoin block header.\nBIP-9 compatible version number that does not signal for …\nThe BIP34 push was negative.\nNo push was present where the BIP34 push was expected.\nThe original Bitcoin Block v1.\nThe number of bytes that the block header contributes to …\nBIP-34 Block v2.\nThe BIP34 push was larger than 8 bytes.\nThe block does not support BIP34 yet.\nA block validation error.\nBitcoin block version number.\nReturns the block height, as encoded in the coinbase …\nThe target value below which the blockhash must lie.\nReturns the block hash.\nReturns the block hash.\nChecks if merkle root of header matches merkle root of the …\nChecks if witness commitment in coinbase matches the …\nReturns the coinbase transaction, if one is present.\nComputes the transaction merkle root.\nComputes the witness commitment for the block’s …\nComputes the popular “difficulty” measure for mining.\nComputes the popular “difficulty” measure for mining …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>Version</code> from a signed 32 bit integer value.\nThe block header\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether the version number is signalling a soft …\nThe root hash of the merkle tree of transactions in the …\nThe nonce, selected to obtain a low enough blockhash.\nReference to the previous block in the chain.\nReturns the stripped size of the block.\nComputes the target (range [0, T] inclusive) that a …\nThe timestamp of the block, as claimed by the miner.\nReturns the inner <code>i32</code> value.\nReturns the total block size.\nList of transactions contained in the block\nChecks that the proof-of-work for the block is valid, …\nBlock version, now repurposed for soft fork signalling.\nReturns the weight of the block.\nComputes the merkle root of transactions hashed for …\nReturns the total work of the block.\n<code>ChainHash</code> for mainnet bitcoin.\nNumber of blocks needed for an output from a coinbase …\nThe uniquely identifying hash of the target blockchain.\nHow many blocks between diffchanges.\nHow much time on average should occur between diffchanges.\nThe maximum allowed number of signature check operations …\nThe maximum allowed weight for a block, see BIP 141 …\nMaximum allowed value for an integer in Script.\nThe maximum allowed script size.\nThe minimum transaction weight for a valid serialized …\nMainnet (bitcoin) pubkey address prefix.\nTest (tesnet, signet, regtest) pubkey address prefix.\n<code>ChainHash</code> for regtest bitcoin.\nMainnet (bitcoin) script address prefix.\nTest (tesnet, signet, regtest) script address prefix.\n<code>ChainHash</code> for signet bitcoin.\nHow may blocks between halvings.\nHow many seconds between blocks we expect on average.\n<code>ChainHash</code> for testnet bitcoin.\nThe factor that non-witness serialization data is …\nReturns a reference the underlying bytes.\nConverts the object to a mutable raw pointer.\nConverts the object to a raw pointer.\nReturns the argument unchanged.\nConverts genesis block hash into <code>ChainHash</code>.\nConstructs and returns the genesis block.\nCalls <code>U::from(self)</code>.\nReturns whether the object, as an array, is empty. Always …\nReturns the length of the object as an array.\nReturns the underlying bytes.\nReturns the hash of the <code>network</code> genesis block for use as a …\nMinimum fee rate required to broadcast a transaction.\nFee rate used to compute dust amount.\nRepresents fee rate.\nMaximum possible value.\nMinimum possible value (0 sat/kwu).\n0 sat/kwu.\nChecked division.\nChecked multiplication.\nChecked weight multiplication.\nCalculates fee by multiplying this fee rate by weight, in …\nCalculates fee by multiplying this fee rate by weight, in …\nReturns the argument unchanged.\nConstructs <code>FeeRate</code> from satoshis per 1000 weight units.\nConstructs <code>FeeRate</code> from satoshis per virtual bytes.\nConstructs <code>FeeRate</code> from satoshis per virtual bytes without …\nCalls <code>U::from(self)</code>.\nReturns raw fee rate.\nConverts to sat/vB rounding up.\nConverts to sat/vB rounding down.\nProvides type <code>LockTime</code> that implements the logic around …\nProvides type <code>LockTime</code> that implements the logic around …\nA block height lock time value.\nAn error occurred while converting a <code>u32</code> to a lock time …\nAn error that occurs when converting a <code>u32</code> to a lock time …\nCatchall type for errors that relate to time locks.\nAn absolute block height, guaranteed to always contain a …\nCannot compare different lock time units (height vs time).\nThe Threshold for deciding whether a lock time value is a …\nAn absolute lock time value, representing either a block …\nThe maximum absolute block height.\nThe maximum absolute block time (Sun Feb 07 2106 06:28:15 …\nThe minimum absolute block height (0), the genesis block.\nThe minimum absolute block time (Tue Nov 05 1985 00:53:20 …\nAn error occurred while operating on lock times.\nErrors than occur when operating on lock times.\nAn error occurred while parsing a string into an <code>u32</code>.\nThe number of bytes that the locktime contributes to the …\nA UNIX timestamp lock time value.\nA UNIX timestamp, seconds since epoch, guaranteed to …\nIf <code>crate::Transaction::lock_time</code> is set to zero it is …\nAbsolute block height 0, the genesis block.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a <code>LockTime</code> from an nLockTime value or the …\nConstructs a new block height.\nConstructs a new block time.\nConstructs a <code>LockTime</code> from <code>n</code>, expecting <code>n</code> to be a valid …\nConstructs a <code>LockTime</code> from <code>n</code>, expecting <code>n</code> to be a valid …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if this lock time value is a block height.\nReturns true if this lock time value is a block time (UNIX …\nReturns true if satisfaction of <code>other</code> lock time implies …\nReturns true if both lock times use the same unit i.e., …\nReturns true if this timelock constraint is satisfied by …\nThe maximum absolute block height.\nThe maximum absolute block time.\nThe minimum absolute block height (0), the genesis block.\nThe minimum absolute block time.\nReturns the inner <code>u32</code> value. This is the value used when …\nConverts this <code>Height</code> to its inner <code>u32</code> value.\nConverts this <code>Time</code> to its inner <code>u32</code> value.\nA block height lock time value.\nErrors related to relative lock times.\nA relative lock time lock-by-blockheight value.\nTried to satisfy a lock-by-blocktime lock using a height …\nTried to satisfy a lock-by-blockheight lock using a time …\nInput time in seconds was too large to be encoded to a 16 …\nA relative lock time value, representing either a block …\nThe maximum relative block height.\nThe maximum relative block time (33,554,432 seconds or …\nThe minimum relative block height (0), can be included in …\nThe minimum relative block time (0), can be included in …\nA relative lock time lock-by-blocktime value.\nA 512 second time interval value.\nRelative block height 0, can be included in any block.\nRelative block time 0, can be included in any block.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>Time</code> using time intervals where each interval is …\nCreate a <code>Time</code> from seconds, converting the seconds into …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if satisfaction of <code>other</code> lock time implies …\nReturns true if this <code>relative::LockTime</code> is satisfied by …\nReturns true if this <code>relative::LockTime</code> is satisfied by …\nReturns true if this <code>relative::LockTime</code> is satisfied by …\nThe maximum relative block height.\nThe maximum relative block time.\nThe minimum relative block height (0), can be included in …\nThe minimum relative block time.\nReturns the inner <code>u16</code> value.\nReturns the inner <code>u16</code> value.\nBroad categories of opcodes with similar behavior.\nClassification context for the opcode.\nFails the script even if not executed.\nOpcode used in legacy context.\nDoes nothing.\nPush an empty array onto the stack.\nEmpty stack is also FALSE.\nPreviously called OP_NOP2.\nPreviously called OP_NOP3.\nNumber 1 is also TRUE.\nA script Opcode.\nAny opcode not covered above.\nPushes the given number of bytes onto the stack.\nPushes the given number onto the stack.\nFails the script if executed.\nSucceeds the script even if not executed.\nOpcode used in tapscript context.\nEnables wildcard imports to bring into scope all opcodes …\nClassifies an Opcode into a broad class.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEncodes <code>Opcode</code> as a byte.\nMap 0 to 0 and everything else to 1, in place.\nIncrement the top stack element in place.\nDecrement the top stack element in place.\nFail the script unconditionally, does not even need to be …\nDrops the top two stack items.\nDuplicates the top two stack items as AB -&gt; ABAB.\nFail the script unconditionally, does not even need to be …\nCopies the two stack items of items two spaces back to the …\nMoves the two stack items four spaces back to the front, …\nSwaps the top two pairs, as ABCD -&gt; CDAB.\nDuplicates the two three stack items as ABC -&gt; ABCABC.\nAbsolute value the top stack item in place.\nPop two stack items and push their sum.\nFail the script unconditionally, does not even need to be …\nPop the top two stack items and push 1 if both are …\nPop the top two stack items and push 1 if either is …\nFail the script unconditionally, does not even need to be …\nPop N, N pubkeys, M, M signatures, a dummy (due to bug in …\nLike the above but return success/failure.\nhttps://en.bitcoin.it/wiki/OP_CHECKSIG pushing 1/0 for …\nOP_CHECKSIGADD post tapscript.\nhttps://en.bitcoin.it/wiki/OP_CHECKSIG returning …\n…\nIgnore this and everything preceding when deciding what to …\n…\nPush the current number of stack items onto the stack.\nFail the script unconditionally, does not even need to be …\nDrops the top stack item.\nDuplicates the top stack item.\nExecute statements if those after the previous OP_IF were …\nPop and execute the next statements if a zero element was …\nPushes 1 if the inputs are exactly equal, 0 otherwise.\nReturns success if the inputs are exactly equal, failure …\nPop one element from the alt stack onto the main stack.\nPop the top two items; push 1 if the second is greater …\nPop the top two items; push 1 if the second is &gt;= the top, …\nPop the top stack item and push its RIPEMD(SHA256) hash.\nPop the top stack item and push its SHA256(SHA256) hash.\nPop and execute the next statements if a nonzero element …\nDuplicate the top stack element unless it is zero.\nSynonym for OP_RETURN.\nFail the script unconditionally, does not even need to be …\nFail the script unconditionally, does not even need to be …\nPop the top two items; push 1 if the second is less than …\nPop the top two items; push 1 if the second is &lt;= the top, …\nFail the script unconditionally, does not even need to be …\nPop the top two items; push the larger.\nPop the top two items; push the smaller.\nFail the script unconditionally, does not even need to be …\nFail the script unconditionally, does not even need to be …\nMultiply the top stack item by -1 in place.\nDrops the second-to-top stack item.\nDoes nothing.\nDoes nothing.\nDoes nothing.\nDoes nothing.\nDoes nothing.\nDoes nothing.\nDoes nothing.\nDoes nothing.\nDoes nothing.\nMap 0 to 1 and everything else to 0, in place.\nPop and execute the next statements if a zero element was …\nPop the top two stack items and push 1 if both are …\nPop the top two stack items and return success if both are …\nPop the top two stack items and push 0 if both are …\nFail the script unconditionally, does not even need to be …\nCopies the second-to-top stack item, as xA -&gt; AxA.\nPop the top stack element as N. Copy the Nth stack element …\nPush an empty array onto the stack.\nPush the next byte as an array onto the stack.\nPush the next 10 bytes as an array onto the stack.\nPush the next 11 bytes as an array onto the stack.\nPush the next 12 bytes as an array onto the stack.\nPush the next 13 bytes as an array onto the stack.\nPush the next 14 bytes as an array onto the stack.\nPush the next 15 bytes as an array onto the stack.\nPush the next 16 bytes as an array onto the stack.\nPush the next 17 bytes as an array onto the stack.\nPush the next 18 bytes as an array onto the stack.\nPush the next 19 bytes as an array onto the stack.\nPush the next 2 bytes as an array onto the stack.\nPush the next 20 bytes as an array onto the stack.\nPush the next 21 bytes as an array onto the stack.\nPush the next 22 bytes as an array onto the stack.\nPush the next 23 bytes as an array onto the stack.\nPush the next 24 bytes as an array onto the stack.\nPush the next 25 bytes as an array onto the stack.\nPush the next 26 bytes as an array onto the stack.\nPush the next 27 bytes as an array onto the stack.\nPush the next 28 bytes as an array onto the stack.\nPush the next 29 bytes as an array onto the stack.\nPush the next 3 bytes as an array onto the stack.\nPush the next 30 bytes as an array onto the stack.\nPush the next 31 bytes as an array onto the stack.\nPush the next 32 bytes as an array onto the stack.\nPush the next 33 bytes as an array onto the stack.\nPush the next 34 bytes as an array onto the stack.\nPush the next 35 bytes as an array onto the stack.\nPush the next 36 bytes as an array onto the stack.\nPush the next 37 bytes as an array onto the stack.\nPush the next 38 bytes as an array onto the stack.\nPush the next 39 bytes as an array onto the stack.\nPush the next 4 bytes as an array onto the stack.\nPush the next 40 bytes as an array onto the stack.\nPush the next 41 bytes as an array onto the stack.\nPush the next 42 bytes as an array onto the stack.\nPush the next 43 bytes as an array onto the stack.\nPush the next 44 bytes as an array onto the stack.\nPush the next 45 bytes as an array onto the stack.\nPush the next 46 bytes as an array onto the stack.\nPush the next 47 bytes as an array onto the stack.\nPush the next 48 bytes as an array onto the stack.\nPush the next 49 bytes as an array onto the stack.\nPush the next 5 bytes as an array onto the stack.\nPush the next 50 bytes as an array onto the stack.\nPush the next 51 bytes as an array onto the stack.\nPush the next 52 bytes as an array onto the stack.\nPush the next 53 bytes as an array onto the stack.\nPush the next 54 bytes as an array onto the stack.\nPush the next 55 bytes as an array onto the stack.\nPush the next 56 bytes as an array onto the stack.\nPush the next 57 bytes as an array onto the stack.\nPush the next 58 bytes as an array onto the stack.\nPush the next 59 bytes as an array onto the stack.\nPush the next 6 bytes as an array onto the stack.\nPush the next 60 bytes as an array onto the stack.\nPush the next 61 bytes as an array onto the stack.\nPush the next 62 bytes as an array onto the stack.\nPush the next 63 bytes as an array onto the stack.\nPush the next 64 bytes as an array onto the stack.\nPush the next 65 bytes as an array onto the stack.\nPush the next 66 bytes as an array onto the stack.\nPush the next 67 bytes as an array onto the stack.\nPush the next 68 bytes as an array onto the stack.\nPush the next 69 bytes as an array onto the stack.\nPush the next 7 bytes as an array onto the stack.\nPush the next 70 bytes as an array onto the stack.\nPush the next 71 bytes as an array onto the stack.\nPush the next 72 bytes as an array onto the stack.\nPush the next 73 bytes as an array onto the stack.\nPush the next 74 bytes as an array onto the stack.\nPush the next 75 bytes as an array onto the stack.\nPush the next 8 bytes as an array onto the stack.\nPush the next 9 bytes as an array onto the stack.\nRead the next byte as N; push the next N bytes as an array …\nRead the next 2 bytes as N; push the next N bytes as an …\nRead the next 4 bytes as N; push the next N bytes as an …\nPush the array <code>0x01</code> onto the stack.\nPush the array <code>0x0a</code> onto the stack.\nPush the array <code>0x0b</code> onto the stack.\nPush the array <code>0x0c</code> onto the stack.\nPush the array <code>0x0d</code> onto the stack.\nPush the array <code>0x0e</code> onto the stack.\nPush the array <code>0x0f</code> onto the stack.\nPush the array <code>0x10</code> onto the stack.\nPush the array <code>0x02</code> onto the stack.\nPush the array <code>0x03</code> onto the stack.\nPush the array <code>0x04</code> onto the stack.\nPush the array <code>0x05</code> onto the stack.\nPush the array <code>0x06</code> onto the stack.\nPush the array <code>0x07</code> onto the stack.\nPush the array <code>0x08</code> onto the stack.\nPush the array <code>0x09</code> onto the stack.\nPush the array <code>0x81</code> onto the stack.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nFail the script immediately. (Must be executed.).\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nSynonym for OP_RETURN.\nFail the script unconditionally, does not even need to be …\nPop the top stack item and push its RIPEMD160 hash.\nPop the top stack element as N. Move the Nth stack element …\nRotate the top three stack items, as [top next1 next2] -&gt; […\nFail the script unconditionally, does not even need to be …\nPop the top stack item and push its SHA1 hash.\nPop the top stack item and push its SHA256 hash.\nPushes the length of the top stack item onto the stack.\nPop two stack items and push the second minus the top.\nFail the script unconditionally, does not even need to be …\nSwap the top two stack items.\nPop one element from the main stack onto the alt stack.\nCopy the top stack item to before the second item, as [top …\nSynonym for OP_RETURN.\nFail the script unconditionally, does not even need to be …\nIf the top value is zero or the stack is empty, fail; …\nFail the script unconditionally, does not even need to be …\nPop the top three items; if the top is &gt;= the second and &lt; …\nFail the script unconditionally, does not even need to be …\nAn Object which can be used to construct a script piece by …\nIterator over bytes of a script\nSome opcode expected a parameter but it was missing or …\nWays that a script might fail. Not everything is split up …\nA “parsed opcode” which allows iterating over a <code>Script</code> …\nIterator over script instructions with their positions.\nIterator over a script returning parsed opcodes.\nSomething did a non-minimal push; for more information see …\nTried to read an array off the stack as a number when it …\nSome non-push opcode.\nByte slices that can be in Bitcoin script.\nPush a bunch of data.\nOwned, growable counterpart to <code>PushBytes</code>.\nError returned on attempt to create too large <code>PushBytes</code>.\nReports information about failed conversion into <code>PushBytes</code>.\nBitcoin script slice.\nAn owned, growable script.\nA hash of Bitcoin Script bytecode.\nCan not serialize the spending transaction.\nCan not find the spent output.\nSegWit version of a Bitcoin Script bytecode hash.\nReturns the script data as a byte slice.\nReturns script bytes\nReturns the underlying bytes.\nReturns the script data as a mutable byte slice.\nReturns the underlying mutbale bytes.\nExtracts mutable <code>PushBytes</code> slice\nReturns a mutable reference to unsized script.\nExtracts <code>PushBytes</code> slice\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nReturns the internal script\nViews the remaining script as a slice.\nViews the remaining script as a slice.\nReturns a reference to unsized script.\nCreates a new script builder\nCreates a new script builder\nReturns an iterator over script bytes.\nReturns the number of bytes the buffer can contain without …\nRemove all bytes from buffer without affecting capacity.\nCounts the sigops for this Script using accurate counting.\nCounts the sigops for this Script using legacy counting.\nReturns the minimum value an output with this script …\nCreates an empty <code>PushBytes</code>.\nTry appending a slice to <code>PushBytesBuf</code>\nReturns the first opcode of the script (if there is any).\nWrites the assembly decoding of the script to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTreat byte slice as <code>Script</code>\nConverts byte vector into script.\nTreat mutable byte slice as <code>Script</code>\nCreates a <code>ScriptBuf</code> from a hex string.\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nHow many bytes the input had.\nIterates over the script instructions and their indices.\nIterates over the script instructions and their indices …\nIterates over the script instructions.\nIterates over the script instructions while enforcing …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts this <code>ScriptBuf</code> into a boxed <code>Script</code>.\nConverts the <code>Builder</code> into script bytes\nConverts the script into a byte vector.\nConverts the <code>Builder</code> into <code>ScriptBuf</code>.\nConverts a <code>Box&lt;Script&gt;</code> into a <code>ScriptBuf</code> without copying or …\nReturns whether the script is the empty script.\nChecks whether the script is the empty script.\nReturns true if the buffer contains zero bytes.\nReturns true if the buffer contains zero bytes.\nChecks whether a script pubkey is a bare multisig output.\nCheck if this is an OP_RETURN output.\nChecks whether a script pubkey is a P2PK output.\nChecks whether a script pubkey is a P2PKH output.\nChecks whether a script pubkey is a P2SH output.\nChecks whether a script pubkey is a P2TR output.\nChecks whether a script pubkey is a P2WPKH output.\nChecks whether a script pubkey is a P2WSH output.\nChecks whether a script can be proven to have no …\nChecks whether a script is push only.\nChecks whether a script pubkey is a P2WPKH output.\nChecks whether a script pubkey is a P2WSH output.\nChecks whether a script pubkey is a P2TR output.\nChecks whether a script pubkey is a Segregated Witness …\nReturns the length in bytes of the script.\nReturns the length in bytes of the script.\nReturns the number of bytes in buffer.\nReturns the number of bytes in buffer.\nCreates a new empty script.\nCreates a new empty script.\nCreates a new empty script.\nCreates a new empty <code>PushBytesBuf</code>.\nGenerates OP_RETURN-type of scriptPubkey for the given …\nGenerates P2PK-type of scriptPubkey.\nGenerates P2PKH-type of scriptPubkey.\nGenerates P2SH-type of scriptPubkey with a given hash of …\nGenerates P2TR for script spending path using an internal …\nGenerates P2TR for key spending path for a known …\nGenerates P2WPKH-type of scriptPubkey.\nGenerates P2WSH-type of scriptPubkey with a given hash of …\nGenerates P2WPKH-type of scriptPubkey.\nGenerates P2WSH-type of scriptPubkey with a given hash of …\nGenerates P2TR for script spending path using an internal …\nGenerates P2TR for key spending path for a known …\nGenerates P2WSH-type of scriptPubkey with a given …\nReturns the opcode if the instruction is not a data push.\nReturns the public key if this script is P2PK with a <strong>valid</strong> …\nReturns the script code used for spending a P2WPKH output …\nRemove the last byte from buffer if any.\nTry pushing a single byte.\nReturns the pushed bytes if the instruction is a data push.\nAdd a single instruction to the script.\nLike push_instruction, but avoids calling <code>reserve</code> to not …\nAdds instructions to push an integer onto the stack.\nAdds instructions to push a public key onto the stack.\nAdds instructions to push an absolute lock time onto the …\nAdds a single opcode to the script.\nAdds a single opcode to the script.\nAdds instructions to push a sequence number onto the stack.\nAdds instructions to push some arbitrary data onto the …\nAdds instructions to push some arbitrary data onto the …\nAdds an <code>OP_VERIFY</code> to the script or replaces the last …\nAdds instructions to push an XOnly public key onto the …\nDecodes a boolean.\nDecodes an integer in script(minimal CScriptNum) format.\nDecodes an integer in script format without non-minimal …\nRemove the byte at <code>index</code> and return it.\nPre-allocates at least <code>additional_len</code> bytes if needed.\nReserve capacity for <code>additional_capacity</code> bytes.\nPre-allocates exactly <code>additional_len</code> bytes if needed.\nAdds an <code>OP_VERIFY</code> to the script or replaces the last …\nReturns 160-bit hash of the script.\nReturns the number interpretted by the script parser if it …\nUser-facing serialization for <code>Script</code>.\nUser-facing serialization for <code>Script</code>.\nComputes leaf hash of tapscript.\nReturns the assembly decoding of the script.\nReturns a copy of the script data.\nFormats the script as lower-case hex.\nComputes the P2SH output corresponding to this redeem …\nComputes P2TR output with a given internal key and a …\nComputes the P2WSH output corresponding to this …\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nComputes the P2WSH output corresponding to this …\nComputes P2TR output with a given internal key and a …\nRemove bytes from buffer past <code>len</code>.\nCreates a new empty script with pre-allocated capacity.\nCreates a new empty <code>PushBytesBuf</code> with reserved capacity.\nThe segregated witness program as defined by BIP141.\nThe segregated witness version byte as defined by BIP141.\nReturns witness version of the script, if any, assuming …\nEncodes an integer in script(minimal CScriptNum) format.\nReturns 256-bit hash of the script for P2WSH outputs.\nWitness program error.\nThe witness program must be between 2 and 40 bytes in …\nA v0 witness program must be either of length 20 or 32.\nThe segregated witness program.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new witness program.\nReturns the witness program.\nReturns the witness program version.\nCannot create a witness version from non-zero data push.\nError parsing <code>WitnessVersion</code> from a string.\nString contained an invalid witness version number.\nCannot not convert OP to a witness version.\nError attempting to create a <code>WitnessVersion</code> from an …\nError attempting to create a <code>WitnessVersion</code> from an …\nUnable to parse integer from string.\nInitial version of witness program. Used for P2WPKH and …\nVersion of witness program used for Taproot P2TR outputs.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nFuture (unsupported) version of witness program.\nVersion of the segregated witness program.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe invalid non-witness version integer.\nConverts this witness version to a GF32 field element.\nReturns integer version number representation for a given …\nThe sequence number that enables absolute lock time but …\nThe sequence number that enables replace-by-fee and …\nError in general format.\nWeight prediction of an individual input.\nThe maximum allowable sequence number.\nMaximum transaction weight for Bitcoin Core 25.0.\nThis is used as a “null txout” in consensus signing …\nThe original Bitcoin transaction version (pre-BIP-68).\nA reference to a transaction output.\nInput weight prediction corresponding to spending of …\nInput weight prediction corresponding to spending of …\nInput weight prediction corresponding to spending of …\nAn error in parsing an OutPoint.\nBitcoin transaction input sequence number.\nThe second Bitcoin transaction version (post-BIP-68).\nSize exceeds max.\nBitcoin transaction.\nBitcoin transaction input.\nBitcoin transaction output.\nError in TXID part.\nThe transaction version.\nError in vout part.\nVout part is not strictly numeric without leading zeroes.\nZero value sequence.\nReturns the base size of this input.\nReturns the base transaction size.\nThe default value of sequence is 0xffffffff.\nReturns <code>true</code> if the sequence number enables absolute …\nReturns true if this input enables the <code>absolute::LockTime</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a relative lock-time using time intervals where …\nCreates a sequence from a u32 value.\nCreates a relative lock-time using block height.\nCreates a relative lock-time from seconds, converting the …\nCreates a relative lock-time from seconds, converting the …\nComputes the prediction for a single input in <code>const</code> …\nInput weight prediction corresponding to spending of …\nList of transaction inputs.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if this <code>Transaction</code>’s absolute timelock is …\nChecks if this is a coinbase transaction.\nChecks if this is a coinbase transaction.\nReturns <code>true</code> if the transaction itself opted in to be …\nReturns <code>true</code> if the sequence number indicates that the …\nReturns <code>true</code> if the sequence number encodes a block based …\nReturns <code>true</code> if this transactions nLockTime is enabled (…\nChecks if an <code>OutPoint</code> is “null”.\nReturns true if the transaction opted-in to BIP125 …\nReturns <code>true</code> if the sequence has a relative lock-time.\nReturns true if this transaction version number is …\nReturns <code>true</code> if the sequence number encodes a time …\nThe weight of the TxIn when it’s included in a legacy …\nBlock height or timestamp. Transaction cannot be included …\nThe maximum allowable sequence number.\nCreates a <code>TxOut</code> with given script and the smallest …\nCreates a new <code>OutPoint</code>.\nComputes the prediction for a single input.\nCreates a non-standard transaction version.\nComputes a “normalized TXID” which does not include …\nCreates a “null” <code>OutPoint</code>.\nList of transaction outputs.\nPredicts the weight of a to-be-constructed transaction.\nPredicts the weight of a to-be-constructed transaction in …\nThe reference to the previous output that is being used as …\nThe script which must be satisfied for the output to be …\nReturns an iterator over lengths of <code>script_pubkey</code>s in the …\nThe script which pushes values on the stack which will …\nThe weight of the TxIn when it’s included in a segwit …\nThe sequence number, which suggests to miners which of two …\nReturns the total number of bytes that this output …\nReturns the size of this transaction excluding the witness …\nReturns the inner 32bit integer value of Sequence.\nCreates a <code>relative::LockTime</code> from this <code>Sequence</code> number.\nCounts the total number of sigops.\nReturns the total number of bytes that this input …\nReturns the total transaction size.\nComputes the <code>Txid</code>.\nThe referenced transaction’s txid.\nThe value of the output, in satoshis.\nThe protocol version, is currently expected to be 1 or 2 …\nThe index of the referenced output in its transaction’s …\nReturns the “virtual size” (vsize) of this transaction.\nThe weight of this output.\nReturns the weight of this transaction, as defined by …\nWitness data: an array of byte-arrays. Note that this …\nComputes the segwit version of the transaction id.\nMaximum possible value.\nThe maximum allowed weight for a block, see BIP 141 …\nMinimum possible value (0 wu).\nThe minimum transaction weight for a valid serialized …\nThe factor that non-witness serialization data is …\nRepresents block weight - the weight of a transaction or …\n0 wu.\nChecked addition.\nChecked division.\nChecked multiplication.\nChecked subtraction.\nReturns the argument unchanged.\nConstructs <code>Weight</code> from kilo weight units returning <code>None</code> if …\nConstructs <code>Weight</code> from non-witness size.\nConstructs <code>Weight</code> from virtual bytes, returning <code>None</code> on …\nConstructs <code>Weight</code> from virtual bytes without an overflow …\nConstructs <code>Weight</code> from witness size.\nDirectly constructs <code>Weight</code> from weight units.\nDirectly constructs <code>Weight</code> from usize weight units.\nCalls <code>U::from(self)</code>.\nScale by witness factor.\nConverts to kilo weight units rounding down.\nConverts to vB rounding up.\nConverts to vB rounding down.\nReturns raw weight units.\nAn iterator returning individual witness elements.\nThe Witness is the data used to unlock bitcoin since the …\nClear the witness.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>Witness</code> object from a slice of bytes slices …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the witness contains no element.\nReturns a struct implementing <code>Iterator</code>.\nReturns the last element in the witness, if any.\nReturns the number of elements this witness holds.\nCreates a new empty <code>Witness</code>.\nReturn the nth element in the witness, if any\nCreates a witness required to spend a P2WPKH output.\nPush a new element on the witness, requires an allocation.\nPushes a DER-encoded ECDSA signature with a signature hash …\nPushes, as a new element on the witness, an ECDSA …\nReturns the second-to-last element in the witness, if any.\nReturns the bytes required when this Witness is consensus …\nReturns the number of bytes this witness contributes to a …\nGet Tapscript following BIP341 rules regarding accounting …\nConvenience method to create an array of byte-arrays from …\nBitcoin consensus-encodable types.\nBitcoin consensus parameters.\nSerde serialization via consensus encoding\nData and a 4-byte checksum.\nData which can be encoded in a consensus-consistent way.\nData which can be encoded in a consensus-consistent way.\nEncoding error.\nChecksum was invalid.\nAnd I/O error.\nMaximum size, in bytes, of a vector we are allowed to …\nVarInt was encoded in a non-minimal way.\nTried to allocate an oversized vector.\nParsing error.\nExtensions of <code>Read</code> to decode data as per Bitcoin consensus.\nUnsupported Segwit flag.\nA variable-length unsigned integer.\nExtensions of <code>Write</code> to encode data as per Bitcoin …\nReturns the checksum of the data.\nDecode an object with a well-defined format.\nDecode <code>Self</code> from a size-limited reader.\nEncodes an object with a well-defined format.\nReturns a reference to the raw data without the checksum.\nDeserializes an object from a vector, will error if said …\nDeserializes an object from a vector, but will not report …\nOutputs a boolean.\nOutputs a 16-bit signed integer.\nOutputs a 32-bit signed integer.\nOutputs a 64-bit signed integer.\nOutputs an 8-bit signed integer.\nOutputs a byte slice.\nOutputs a 16-bit unsigned integer.\nOutputs a 32-bit unsigned integer.\nOutputs a 64-bit unsigned integer.\nOutputs an 8-bit unsigned integer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the raw data without the checksum.\nGets the length of this VarInt when encoded.\nCreates a new <code>CheckedData</code> computing the checksum of given …\nReads a boolean.\nReads a 16-bit signed integer.\nReads a 32-bit signed integer.\nReads a 64-bit signed integer.\nReads an 8-bit signed integer.\nReads a byte slice.\nReads a 16-bit unsigned integer.\nReads a 32-bit unsigned integer.\nReads a 64-bit unsigned integer.\nReads an 8-bit unsigned integer.\nEncodes an object into a vector.\nEncodes an object into a hex-encoded string.\nReturns the number of bytes this varint contributes to a …\nThe invalid checksum.\nThe expected checksum.\nThe maximum capacity.\nThe capacity requested.\nParameters that influence chain consensus.\nDetermines whether minimal difficulty may be used for …\nTime when BIP16 becomes active.\nBlock height at which BIP34 becomes active.\nBlock height at which BIP65 becomes active.\nBlock height at which BIP66 becomes active.\nCalculates the number of blocks between difficulty …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nNumber of blocks with the same set of rules.\nNetwork for which parameters are valid.\nCreates parameters set for the given network.\nDetermines whether retargeting is disabled for this …\nProof of work limit value. It contains the lowest possible …\nExpected amount of time to mine one block.\nDifficulty recalculation interval.\nMinimum blocks including miner confirmation of the total …\nProvides an instance of string-to-byte decoder.\nProvides an instance of byte-to-string encoder.\nError returned when decoding fails.\nThe decoder state.\nTransforms given bytes and writes to the writer.\nThe encoder state.\nHex-encoding strategy\nError returned when decoder can’t be created.\nConverts error into a type implementing <code>serde::de::Error</code>\nHelper for <code>#[serde(with = &quot;&quot;)]</code>.\nDeserializes the value as consensus-encoded\nTransform the provided slice and write to the writer.\nWrite data in buffer (if any) to the writer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs the decoder from string.\nImplements hex encoding.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPerforms the conversion.\nSerializes the value as consensus-encoded\nMarker for upper/lower case type-level flags (“…\nError returned when a hex string contains invalid …\nError returned when a hex string decoder can’t be …\nHex decoder state.\nHex byte encoder.\nMarker for using lower-case hex encoding.\nMarker for using upper-case hex encoding.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSignature was empty.\nAn ECDSA signature-related error.\nHex decoding error.\nA secp256k1 error.\nHolds signature serialized in-line (not in <code>Vec</code>).\nNon-standard sighash type.\nAn ECDSA signature with the corresponding hash type.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserializes from slice following the standardness rules …\nThe corresponding hash type\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator over bytes of the signature.\nSerializes an ECDSA signature (inner secp256k1 signature …\nThe underlying ECDSA Signature\nConstructs an ECDSA bitcoin signature for …\nSerializes an ECDSA signature (inner secp256k1 signature …\nError with rich context returned when a string can’t be …\nReturns the argument unchanged.\nReturns the input that was attempted to be parsed.\nCalls <code>U::from(self)</code>.\nA bitcoin block hash.\nFilter hash, as defined in BIP-157\nFilter header, as defined in BIP-157\nA hash of the Merkle tree branch or root for transactions\nA bitcoin transaction hash/transaction ID.\nA hash corresponding to the witness structure commitment …\nA hash corresponding to the Merkle tree root for witness …\nA bitcoin witness transaction ID.\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nComputes the filter header from a filter hash and previous …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nA base58 error.\nA key-related error.\nEven parity.\nHex decoding error.\n<code>PublicKey</code> hex should be 66 or 130 digits long.\nInvalid key prefix error.\nOpaque data structure that holds a keypair consisting of a …\nOdd parity.\nRepresents the parity passed between FFI function calls.\nA Bitcoin ECDSA private key\nA hash of a public key.\nA Bitcoin ECDSA public key\nThe secp256k1 engine, used to execute all signature …\nA secp256k1 error.\nAn opaque return type for PublicKey::to_sort_key\nA trait for tweaking BIP340 key types (x-only public keys …\nTweaked key type with optional auxiliary information\nTweaked key type\nTweaked BIP-340 key pair\nTweaked BIP-340 key pair\nTweaked BIP-340 X-coord-only public key\nUntweaked BIP-340 key pair\nUntweaked BIP-340 key pair\nUntweaked BIP-340 X-coord-only public key\nMarker trait for indicating that an instance of <code>Secp256k1</code> …\nSegWit version of a public key hash.\nAn x-only public key, used for verification of Taproot …\nTweaks a keypair by first converting the public key to an …\nObtains a raw mutable pointer suitable for use with FFI …\nObtains a raw const pointer suitable for use with FFI …\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nLike <code>cmp::Cmp</code> but faster and with no guarantees across …\nWhether this public key should be serialized as compressed\nWhether this private key should be serialized as compressed\nConstants related to the API and the underlying curve.\nGetter for the raw pointer to the underlying secp256k1 …\nDirectly converts an <code>UntweakedPublicKey</code> to a …\nCreates a new <code>TweakedPublicKey</code> from a <code>XOnlyPublicKey</code>. No …\nCreates a new <code>TweakedKeypair</code> from a <code>Keypair</code>. No tweak is …\nFormats the explicit byte value of the secret key kept …\nLike <code>cmp::Eq</code> but faster and with no guarantees across …\nFormat the private key to WIF format.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a <code>Parity</code> from a signed integer.\nReturns the <code>TweakedPublicKey</code> for <code>keypair</code>.\nComputes the public key as supposed to be used with this …\nCreates a context from a raw context.\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nCreates a context from a raw context that can only be used …\nCreates a context from a raw context that can only be used …\nCreates a <code>Keypair</code> directly from a secret key slice.\nCreates a <code>Keypair</code> directly from a secret key string.\nCreates a <code>Keypair</code> directly from a Secp256k1 secret key.\nDeserialize a public key from a slice\nDeserialize a private key from a slice\nConstructs a <code>Parity</code> from a byte.\nParse WIF encoded private key.\nLets you create a context in a generic manner …\nGenerates a random keypair. Convenience function for …\nThe actual ECDSA key\nThe actual ECDSA key\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe network on which this key should be used\nCreates a new Secp256k1 context with all capabilities.\nGenerates a new random secret key.\nConstructs compressed ECDSA public key from the provided …\nConstructs compressed ECDSA private key from the provided …\nConstructs uncompressed (legacy) ECDSA public key from the …\nConstructs uncompressed (legacy) ECDSA private key from …\nAttempts to erase the secret within the underlying array.\nUses the ffi <code>secp256k1_context_preallocated_size</code> to check …\nUses the ffi <code>secp256k1_context_preallocated_size</code> to check …\nReturns the required memory for a preallocated context …\nUses the ffi <code>secp256k1_context_preallocated_size</code> to check …\nLets you create a context with a preallocated buffer in a …\nCreates a new Secp256k1 context with all capabilities.\nCreates a new Secp256k1 context that can only be used for …\nCreates a new Secp256k1 context that can only be used for …\nReturns bitcoin 160-bit hash of the public key\nReturns the <code>PublicKey</code> for this <code>Keypair</code>.\nCreates a public key from this private key\nReturns the <code>TweakedPublicKey</code> and its <code>Parity</code> for this …\n(Re)randomizes the Secp256k1 context for extra sidechannel …\nRead the public key from a reader\nDetermines the public key for which <code>sig</code> is a valid …\nReturns the secret bytes for this key pair.\nReturns the <code>SecretKey</code> for this <code>Keypair</code>.\n(Re)randomizes the Secp256k1 context for extra sidechannel …\nSerialize the key as a byte-encoded pair of values. In …\nConstructs a signature for <code>msg</code> using the secret key <code>sk</code> and …\nConstructs a signature for <code>msg</code> using the secret key <code>sk</code>, …\nConstructs a signature for <code>msg</code> using the secret key <code>sk</code>, …\nConstructs a signature for <code>msg</code> using the secret key <code>sk</code> and …\nConstructs a signature for <code>msg</code> using the secret key <code>sk</code> and …\nConstructs a signature for <code>msg</code> using the secret key <code>sk</code> and …\nCreates a schnorr signature internally using the …\nCreates a schnorr signature without using any auxiliary …\nCreates a schnorr signature using the given auxiliary …\nCreates a schnorr signature using the given random number …\nCreates a new Secp256k1 context that can only be used for …\nTweaks an untweaked key with corresponding public key …\nTweaks an untweaked public key with corresponding public …\nTweaks private and public keys within an untweaked <code>Keypair</code> …\nSerialize the public key to bytes\nSerialize the private key to bytes\nConverts parity into an integer value.\nReturns the underlying public key.\nReturns the underlying key pair.\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nSerialize the public key into a <code>SortKey</code>.\nConverts parity into an integer (byte) value.\nGet WIF encoding of this private key.\nCreates a new Secp256k1 context that can only be used for …\nChecks that <code>sig</code> is a valid ECDSA signature for <code>msg</code> using …\nChecks that <code>sig</code> is a valid ECDSA signature for <code>msg</code> using …\nVerifies a schnorr signature.\nReturns bitcoin 160-bit hash of the public key for witness …\nWrite the public key into a writer\nReturns the <code>XOnlyPublicKey</code> (and it’s <code>Parity</code>) for this …\nThe maximum size of a compact signature.\nThe order of the secp256k1 curve.\nThe size of a full ElligatorSwift encoding.\nThe Prime for the secp256k1 field element.\nThe X coordinate of the generator.\nThe Y coordinate of the generator.\nThe size of a key pair.\nThe maximum size of a signature.\nThe size (in bytes) of a message.\nThe value one as big-endian array of bytes.\nThe size (in bytes) of a serialized public key.\nThe size of a schnorr public key.\nThe size of a schnorr signature.\nThe size (in bytes) of a secret key.\nThe size (in bytes) of an serialized uncompressed public …\nThe value zero as an array of bytes.\nOverflowed the bits array\nOverflowed the hashes array\nThe left and right branches should never be identical\nData structure that represents a block header paired to a …\nAn error when verifying the merkle block.\nMerkle root in the header doesn’t match to the root …\nPartial merkle tree contains no transactions.\nNot all bits were consumed\nNot all hashes were consumed\nThere must be at least one bit per node in the partial …\nData structure that represents a partial merkle tree.\nThere are too many hashes\nThere are too many transactions.\nReturns the node-is-parent-of-matched-txid bits of the …\nCalculates the merkle root of an iterator of <em>hashes</em>.\nCalculates the merkle root of a list of <em>hashes</em>, inline (in …\nExtract the matching txid’s represented by this partial …\nExtract the matching txid’s represented by this partial …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a MerkleBlock from a block, that contains proofs …\nCreate a MerkleBlock from the block’s header and txids, …\nConstruct a partial merkle tree The <code>txids</code> are the …\nReturns the transaction ids and internal hashes of the …\nThe block header\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the total number of transactions in the block.\nTransactions making up a partial merkle tree\nMainnet Bitcoin.\nThe cryptocurrency network to act on.\nAn error in parsing network string.\nBitcoin’s regtest network.\nBitcoin’s signet network.\nBitcoin’s testnet network.\nError in parsing network from chain hash.\nModule for serialization/deserialization of network …\nReturn the network’s chain hash (genesis block hash).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>Network</code> from the chain hash (genesis block hash).\nConverts a <code>bitcoind -chain</code> argument name to its equivalent …\nCreates a <code>Network</code> from the magic bytes.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the network magic bytes, which should be encoded …\nConverts a <code>Network</code> to its equivalent <code>bitcoind -chain</code> …\nBitcoin mainnet network magic bytes.\nBLOOM means the node is capable and willing to handle …\nCOMPACT_FILTERS means the node will service basic block …\nGETUTXO means the node is capable of responding to the …\nNetwork magic bytes to identify the cryptocurrency network …\nNETWORK means that the node is capable of serving the …\nNETWORK_LIMITED means the same as NODE_NETWORK with the …\nNONE means no services supported.\nVersion of the protocol as appearing in network message …\nAn error in parsing magic bytes.\nBitcoin regtest network magic bytes.\nBitcoin signet network magic bytes.\nFlags to indicate which network services a node supports.\nBitcoin testnet network magic bytes.\nError in creating a Network from Magic bytes.\nWITNESS indicates that a node can be asked for blocks and …\nAdd ServiceFlags together.\nBitcoin network addresses.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate network magic from bytes.\nCheck whether ServiceFlags are included in this one.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBitcoin network messages.\nBitcoin blockdata network messages.\nBitcoin Connection Bloom filtering network messages.\nBIP152  Compact Blocks network messages\nBitcoin Client Side Block Filtering network messages.\nBitcoin network-related network messages.\nRemove ServiceFlags from this.\nGet network magic bytes.\nGets the integer representation of this <code>ServiceFlags</code>.\nSupported networks for use in BIP155 addrv2 message\nAddress received from BIP155 addrv2 message\nA message which can be sent on the Bitcoin network\nCJDNS\nI2P\nIPV4\nIPV6\nTORV2\nTORV3\nUnknown\nNetwork ID + Network Address\nNetwork byte-order ipv6 address, or ipv4-mapped ipv6 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an address message for a socket\nNetwork port\nNetwork port, 0 if not applicable\nServices provided by the peer whose address this is\nService bits\nExtract socket address from an Address message. This will …\nExtract socket address from an AddrV2Message message. This …\nTime that this node was last seen as connected to the …\n<code>addr</code>\n<code>addrv2</code>\n<code>alert</code>\n<code>block</code>\nBIP152 blocktxn\nBIP157 cfcheckpt\nBIP157 cfheaders\nBIP157 cfilter\nBIP152 cmpctblock\nSerializer for command string\nError returned when a command string is invalid.\n<code>feefilter</code>\nBIP 37 <code>filteradd</code>\nBIP 37 <code>filterclear</code>\nBIP 37 <code>filterload</code>\n<code>getaddr</code>\nBIP152 getblocktxn\n<code>getblocks</code>\nBIP157 getcfcheckpt\nBIP157 getcfheaders\nBIP157 getcfilters\n<code>getdata</code>\n<code>getheaders</code>\n<code>headers</code>\n<code>inv</code>\nThe maximum number of super::message_blockdata::Inventory …\nMaximum size, in bytes, of an encoded message This by …\n<code>mempool</code>\n<code>merkleblock</code>\nA Network message payload. Proper documentation is …\n<code>notfound</code>\n<code>ping</code>\n<code>pong</code>\nA Network message\n<code>reject</code>\n<code>sendaddrv2</code>\nBIP152 sendcmpct\n<code>sendheaders</code>\ntx\nAny other message.\n<code>verack</code>\n<code>version</code>\n<code>wtxidrelay</code>\nReturn the message command as a static string reference.\nReturn the message command as a static string reference.\nReturn the CommandString for the message command.\nReturn the CommandString for the message command.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMagic bytes to identify the network these messages are …\nCreates a RawNetworkMessage\nThe actual message data\nConverts <code>&amp;&#39;static str</code> to <code>CommandString</code>\nThe command of this message.\nThe payload of this message.\nBlock\nCompact Block\nError — these inventories can be ignored\nThe <code>getblocks</code> message\nThe <code>getheaders</code> message\nAn inventory item.\nTransaction\nUnknown inventory type\nWitness Transaction by Wtxid\nWitness Block\nWitness Transaction\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLocator hashes — ordered newest to oldest. The remote …\nLocator hashes — ordered newest to oldest. The remote …\nReturn the item value represented as a SHA256-d hash.\nConstruct a new <code>getblocks</code> message\nConstruct a new <code>getheaders</code> message\nReferences the block to stop at, or zero to just fetch the …\nReferences the header to stop at, or zero to just fetch …\nThe protocol version\nThe protocol version\nThe hash of the inventory item\nThe inventory item type.\nAlways update the filter with outpoints.\nBloom filter update flags\n<code>filteradd</code> message updates the current filter with new data\n<code>filterload</code> message sets the current bloom filter\nNever update the filter with outpoints.\nOnly update the filter with outpoints if it is P2PK or P2MS\nThe data element to add to the current filter.\nThe filter itself\nControls how matched items are added to the filter\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe number of hash functions to use\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA random value\nblocktxn message\ncmpctblock message\ngetblocktxn message\nsendcmpct message\nThe Compact Block.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRequest to be send compact blocks.\nThe requested block transactions.\nThe block transactions request.\nCompact Blocks protocol version number.\ncfcheckpt message\ncfheaders message\ncfilter message\ngetcfcheckpt message\ngetcfheaders message\ngetcfilters message\nBlock hash of the Bitcoin block for which the filter is …\nThe serialized compact filter for this block\nThe filter hashes for each block in the requested range\nThe filter headers at intervals of 1,000\nFilter type for which headers are requested\nByte identifying the type of filter being returned\nByte identifying the type of filter being returned\nFilter type for which headers are requested\nFilter type for which headers are requested\nFilter type for which headers are requested\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe filter header preceding the first block in the …\nThe height of the first block in the requested range\nThe height of the first block in the requested range\nThe hash of the last block in the requested range\nThe hash of the last block in the requested range\nThe hash of the last block in the requested range\nThe hash of the last block in the requested range\nThe hash of the last block in the requested range\ncheckpoint\nduplicate message\nan output is below dust limit\ninsufficient fee\ninvalid message\nmalformed message\nnonstandard transaction\nobsolete message\nReject message might be sent by peers rejecting one of our …\nmessage rejection reason as a code\nSome simple messages The <code>version</code> message\nreason of rejection as code\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nreference to rejected item\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nmessage type rejected\nConstructs a new <code>version</code> message with <code>relay</code> set to false\nA random nonce used to detect loops in the network\nreason of rejectection\nThe network address of the peer receiving the message\nWhether the receiving peer should relay messages to the …\nThe network address of the peer sending the message\nA bitmask describing the services supported by this node\nThe height of the maximum-work blockchain that the peer is …\nThe time at which the <code>version</code> message was sent\nA string describing the peer’s software\nThe P2P network protocol version\nThe number of bytes equivalent per signature operation. …\nThe minimum incremental <em>feerate</em> (despite the name), in …\nDefault number of hours for an unconfirmed transaction to …\nMinimum feerate, in sats per virtual kilobyte, for a …\nThe minimum feerate, in sats per kilo-virtualbyte, for …\nMaximum number of sigops in a standard tx.\nMaximum weight of a transaction for it to be relayed by …\nMinimum non-witness size for a standard transaction (1 …\nThe virtual transaction size, as computed by default by …\nEncoding of 256-bit target as 32-bit float.\nThe maximum possible target.\nThe maximum <strong>attainable</strong> target value on mainnet.\nThe proof of work limit on regtest.\nThe proof of work limit on signet.\nThe proof of work limit on testnet.\nA 256 bit integer representing target.\nError from <code>TryFrom&lt;signed type&gt;</code> implementations, occurs …\nA 256 bit integer representing work.\nWhen parsing nBits, Bitcoin Core converts a negative …\nComputes the popular “difficulty” measure for mining.\nComputes the popular “difficulty” measure for mining …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates <code>Self</code> from a big-endian byte array.\nCreates <code>Self</code> from a big-endian byte array.\nComputes the <code>Target</code> value from a compact representation.\nCreates a <code>CompactTarget</code> from a consensus encoded <code>u32</code>.\nCreates <code>Self</code> from a little-endian byte array.\nCreates <code>Self</code> from a little-endian byte array.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if block hash is less than or equal to this …\nReturns log2 of this work.\nComputes the maximum valid <code>Target</code> threshold allowed for a …\nThe maximum possible target (see <code>Target::MAX</code>).\nComputes the minimum valid <code>Target</code> threshold allowed for a …\nConverts <code>self</code> to a big-endian byte array.\nConverts <code>self</code> to a big-endian byte array.\nComputes the compact value from a <code>Target</code> representation.\nReturns the consensus encoded <code>u32</code> representation of this …\nConverts <code>self</code> to a little-endian byte array.\nConverts <code>self</code> to a little-endian byte array.\nConverts this <code>Work</code> to <code>Target</code>.\nConverts this <code>Target</code> to <code>Work</code>.\nThe <code>FeeRate</code> is too high\nAn output of type: pay-to-pubkey or pay-to-pubkey-hash.\nRequest a private key using BIP-32 fingerprint and …\nA bip32 error.\nConflicting data during combine procedure: global extended …\nSerialization error in bitcoin consensus-encoded structures\nThe default <code>max_fee_rate</code> value used for extracting …\nKeys within key-value map should never be duplicated.\nThe Elliptic Curve Digital Signature Algorithm (see …\nWays that a Partially Signed Transaction might fail.\nAn error occurred while getting the key.\nThis error is returned when extracting a <code>Transaction</code> from …\nInteger overflow in fee calculation\nTrait to get a private key from a key request, key is then …\nErrors when getting a key.\nInput index out of bounds.\nInput index out of bounds (actual index, maximum index …\nA key-value map for an input of the corresponding index in …\nThe index is out of bounds for the <code>psbt.inputs</code> vector.\nParsing error indicating invalid control block\nParsing error indicating invalid ECDSA signatures\nInvalid hash when parsing slice.\nKnown keys must be according to spec.\nParsing error indicating invalid leaf version\nMagic bytes for a PSBT must be the ASCII for “psbt” …\nThe pre-image must hash to the correponding psbt hash\nNon-proprietary key type found when proprietary key was …\nParsing error indicating invalid public keys\nParsing error indicating invalid secp256k1 public keys\nThe separator for a PSBT must be <code>0xff</code>.\nInvalid Sighash type.\nParsing error indicating invalid taproot signatures\nParsing error indicating invalid xonly public keys\nI/O error.\nUnable to find key.\nData required to call <code>GetKey</code> to get the private key to …\nSigning algorithm and key type does not match.\nMissing input utxo.\nOne or more of the inputs lacks value information …\nMissing Redeem script.\nMissing spending utxo.\nMissing both the witness and non-witness utxo.\nMissing witness script.\nA PSBT must have an unsigned transaction.\nNegative fee\nSignals that there are no more key-value pairs in a …\nUnable to parse as a standard sighash type.\nAttempted to ECDSA sign an non-ECDSA input.\nThe GetKey operation is not supported for this key request.\nThe <code>scriptPubkey</code> is not a P2WPKH script.\nA key-value map for an output of the corresponding index …\nThe various output types supported by the Bitcoin network.\nPSBT data is not consumed entirely\nA Partially Signed Transaction.\nA Signature hash type for the corresponding input. As of …\nReturned when output index is out of bounds in relation to …\nRequest a private key using the associated public key.\nThe Schnorr signature algorithm (see wikipedia).\nInput value is less than Output Value, and the <code>Transaction</code> …\nA pay-to-script-hash output excluding wrapped segwit …\nA nested segwit output, pay-to-witness-pubkey-hash nested …\nA nested segwit output, pay-to-witness-script-hash nested …\nSighash computation error.\nErrors encountered while calculating the sighash message.\nSigning algorithms supported by the Bitcoin network.\nMap of input index -&gt; the error encountered while …\nMap of input index -&gt; pubkey associated with secret key …\nTaproot tree deserilaization error\nParsing error indicating a taproot error\nA taproot output (P2TR).\nThe index is out of bounds for the <code>psbt.unsigned_tx.input</code> …\nAttempting to combine with a PSBT describing a different …\nUnable to determine the output type.\nThe scriptSigs for the unsigned transaction must be empty.\nThe scriptWitnesses for the unsigned transaction must be …\nSigning request currently unsupported.\nError related to PSBT version\nA pay-to-witness-pubkey-hash output (P2WPKH).\nAttempt to sign an input with the wrong signing algorithm.\nA pay-to-witness-script-hash output (P2WSH).\nError related to an xpub key\nA map from public keys needed to sign this input to their …\nA map from public keys needed to spend this output to their\nCombines this <code>Input</code> with <code>other</code> <code>Input</code> (as described by BIP …\nCombines this <code>Output</code> with <code>other</code> <code>Output</code> (as described by …\nCombines this <code>Psbt</code> with <code>other</code> PSBT as described by BIP 174.\nDeserialize a value from raw binary data.\nObtains the <code>EcdsaSighashType</code> for this input if one is …\nReturns the <code>EcdsaSighashType</code> if the <code>PsbtSighashType</code> can be …\nAn alias for <code>extract_tx_fee_rate_limit</code>.\nExtracts the <code>Transaction</code> from a <code>Psbt</code> by filling in the …\nPerform <code>extract_tx_fee_rate_limit</code> without the fee rate …\nExtracts the <code>Transaction</code> from a <code>Psbt</code> by filling in the …\nCalculates transaction fee.\nThe finalized, fully-constructed scriptSig with signatures …\nThe finalized, fully-constructed scriptWitness with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>PsbtSighashType</code> from a raw <code>u32</code>.\nCreates a PSBT from an unsigned transaction.\nAttempts to get the private key for <code>key_request</code>.\nHSAH160 hash to preimage map.\nHAS256 hash to preimage map.\nThe corresponding key-value map for each input in the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator for the funding UTXOs of the psbt\nThe non-witness transaction this input spends from. Should …\nThe corresponding key-value map for each output in the …\nA map from public keys to their corresponding signature as …\nProprietary key-value pairs for this input.\nProprietary key-value pairs for this output.\nGlobal proprietary key-value pairs.\nRaw PSBT key-value pairs.\nThe redeem script for this input.\nThe redeem script for this output.\nTODO: Proof of reserves commitment RIPEMD160 hash to …\nPSBT serialization.\nSerialize as raw binary data\nSerialize a value as bytes in hex.\nSHA256 hash to preimage map.\nReturns the sighash message to sign an ECDSA input along …\nThe sighash type to be used for this input. Signatures for …\nAttempts to create <em>all</em> the required signatures for this …\nThe signing algorithm used to sign this output type.\nReturns the spending utxo for this PSBT’s input at …\nTaproot Internal key.\nThe internal pubkey.\nMap of tap root x only keys to origin info and leaf hashes …\nMap of tap root x only keys to origin info and leaf hashes …\nSerialized taproot signature with sighash type for key …\nTaproot Merkle root.\nMap of <code>&lt;xonlypubkey&gt;|&lt;leafhash&gt;</code> with signature.\nMap of Control blocks to Script version pair.\nTaproot Output tree.\nObtains the <code>TapSighashType</code> for this input if one is …\nReturns the <code>TapSighashType</code> if the <code>PsbtSighashType</code> can be …\nConverts <code>PsbtSighashType</code> to a raw <code>u32</code> sighash flag.\nUnknown key-value pairs for this input.\nUnknown key-value pairs for this output.\nUnknown global key-value pairs.\nThe unsigned transaction, scriptSigs and witnesses for …\nThe version number of this PSBT. If omitted, the version …\nThe witness script for this input.\nThe witness script for this output.\nThe transaction output this input spends from. Should only …\nA global map from extended public keys to the used key …\nActual\nExpected\nHash value\nHash-type\nPre-image\nThe <code>FeeRate</code>\nThe original <code>Psbt</code> is returned untouched.\nThe extracted <code>Transaction</code> (use this to ignore the error)\nThe extracted <code>Transaction</code> (use this to ignore the error)\nAttempted index access.\nAttempted index access.\nLength of the PBST inputs vector.\nLength of the PBST’s unsigned transaction input vector.\nA PSBT key in its raw byte form.\nA PSBT key-value pair in its raw byte form. …\nProprietary keys (i.e. keys starting with 0xFC byte) with …\nDefault implementation for proprietary key subtyping\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdditional key bytes (like serialized public key data etc)\nThe key of this key-value pair.\nThe key itself in raw byte form. …\nProprietary type prefix used for grouping together keys …\nCustom proprietary subtype\nConstructs full Key corresponding to this proprietary key …\nConstructs a <code>ProprietaryKey</code> from a <code>Key</code>.\nThe type of this PSBT key.\nThe value data of this key-value pair in raw byte form. …\nWhen <code>SIGHASH_ANYONECANPAY</code> is not provided, or when the …\n0x1: Sign all outputs.\n0x1: Sign all outputs.\n0x81: Sign all outputs but only this input.\n0x81: Sign all outputs but only this input.\nThe <code>Annex</code> struct is a slice wrapper enforcing first byte …\n0x0: Used when not explicitly specified, defaults to …\nHashtype of an input’s signature, encoded in the last …\nResult of <code>SighashCache::legacy_encode_signing_data_to</code>.\nPossible errors in computing the signature message.\nRequested index is greater or equal than the number of …\nInvalid Sighash type.\nInteger is not a consensus valid sighash type.\nCould happen only by using <code>*_encode_signing_*</code> methods with …\nHash of a transaction according to the legacy signature …\nThis type is consensus valid but an input including it …\n0x2: Sign no outputs — anyone can choose the destination.\n0x2: Sign no outputs — anyone can choose the destination.\n0x82: Sign no outputs and only this input.\n0x82: Sign no outputs and only this input.\nScript is not a witness program for a p2wpkh output.\n<code>One</code> variant allows provision of the single prevout needed. …\nRequested a prevout index which is greater than the number …\nA single prevout has been provided but all prevouts are …\nContains outputs of previous transactions. In the case …\nThere are mismatches in the number of prevouts provided …\nInformation related to the script path spending.\nHash of a transaction according to the segwit version 0 …\nEfficiently calculates signature hash message for legacy, …\nInput data is an instance of <code>SIGHASH_SINGLE</code> bug\nError returned for failure during parsing one of the …\n0x3: Sign the output whose index matches this input’s …\n0x3: Sign the output whose index matches this input’s …\n0x83: Sign one output and only this input (see <code>Single</code> for …\n0x83: Sign one output and only this input (see <code>Single</code> for …\nUsing <code>SIGHASH_SINGLE</code> without a “corresponding output” …\nTaproot-tagged hash with tag &quot;TapSighash&quot;.\nThe tag used for <code>TapSighash</code>\nHashtype of an input’s signature, encoded in the last …\nOperation performed normally.\nAnnex must be at least one byte long and the first bytes …\nReturns the Annex bytes data (including first byte <code>0x50</code>).\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>EcdsaSighashType</code> from a raw <code>u32</code>.\nConstructs a <code>TapSighashType</code> from a raw <code>u8</code>.\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nCreates a <code>EcdsaSighashType</code> from a raw <code>u32</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDestroys the cache and recovers the stored transaction.\nChecks for SIGHASH_SINGLE bug returning error if the …\nComputes the leaf hash for this <code>ScriptPath</code>.\nEncodes the legacy signing data from which a signature …\nComputes a legacy signature hash for a given input index …\nMaps a <code>Result&lt;T, E&gt;</code> to <code>Result&lt;T, F&gt;</code> by applying a function …\nConstructs a new <code>SighashCache</code> from an unsigned transaction.\nCreates a new <code>ScriptPath</code> structure.\nCreates a new <code>Annex</code> struct checking the first byte is <code>0x50</code>.\nComputes the BIP143 sighash to spend a p2wpkh transaction …\nComputes the BIP143 sighash to spend a p2wsh transaction …\nEncodes the BIP143 signing data for any flag type into a …\nComputes the BIP143 sighash for any flag type.\nEncodes the BIP143 signing data for any flag type into a …\nEncodes the BIP341 signing data for any flag type into a …\nComputes the BIP341 sighash for a key spend.\nComputes the BIP341 sighash for a script spend.\nComputes the BIP341 sighash for any flag type.\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nConverts <code>EcdsaSighashType</code> to a <code>u32</code> sighash flag.\nReturns the reference to the cached transaction.\nThe unrecognized string we attempted to parse.\nCreates a new <code>ScriptPath</code> structure using default leaf …\nWhen the <code>SighashCache</code> is initialized with a mutable …\nRequested index.\nRequested index.\nNumber of transaction inputs.\nNumber of transaction outputs.\nThe prefix for signed messages using Bitcoin’s message …\nInvalid base64 encoding.\nThe signature is invalidly constructed.\nSignature is expected to be 65 bytes.\nA signature on a Bitcoin Signed Message.\nAn error used for dealing with Bitcoin Signed Messages.\nUnsupported Address Type\nWhether or not this signature was created with a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate from a byte slice.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nVerify that the signature signs the message and was signed …\nCreate a new MessageSignature.\nAttempt to recover a public key from the signature and the …\nSerialize to bytes.\nThe inner recoverable signature.\nHash message for signature using Bitcoin’s message …\nAn error occurred while parsing the hex string.\nHex parsing error\nTrait that allows types to be initialized from hex strings\nThe input is missing <code>0x</code> prefix, contains the invalid input.\nThe input was not a valid hex string, contains the error …\nReturns the argument unchanged.\nParses provided string as hex requiring 0x prefix.\nParses provided string as hex without requiring 0x prefix.\nCalls <code>U::from(self)</code>.\nControl block data structure used in Tapscript …\nCalled finalize on a empty tree.\nEmpty tap tree.\nFuture leaf version.\nInner type representing future (non-tapscript) leaf …\nHidden Node with the given leaf hash\nError happening when <code>TapTree</code> is constructed from a <code>NodeInfo</code>\nIndicates an attempt to construct a tap tree from a …\nIndicates an attempt to construct a tap tree from a …\nError happening when <code>TapTree</code> is constructed from a …\nInvalid control block size.\nInvalid taproot internal key.\nInvalid taproot internal key.\nProof size must be a multiple of 32.\nMerkle tree depth must not be more than 128.\nMerkle tree depth must not be more than 128.\nInvalid parity for internal key.\nInvalid taproot signature size\nThe last bit of tapleaf version must be zero.\nStore information about taproot leaf node.\nIterator for a taproot script tree, operating in DFS order …\nThe leaf version for tapleafs.\nRepresents the node information in taproot tree. In …\nNodes must be added specified in DFS walk order.\nIndicates an attempt to construct a tap tree from a …\nTwo nodes at depth 0 are not allowed.\nA known script\nScript leaf node in a taproot tree along with the merkle …\nIterator for a taproot script tree, operating in DFS order …\nA secp256k1 error.\nAn error constructing a <code>taproot::Signature</code> from a byte …\nInvalid signature hash type.\nA BIP340-341 serialized taproot signature with the …\nTaproot annex prefix.\nTapscript control base size.\nMaximum depth of a taproot tree script spend path.\nTapscript control max size.\nSize of a taproot control node.\nTapleaf mask for getting the leaf version from first byte …\nTapscript leaf version.\nThe tag used for <code>TapNodeHash</code>\nLeaf node in a taproot tree. Can be either hidden or known.\nTaproot-tagged hash with tag &quot;TapLeaf&quot;.\nThe tag used for <code>TapLeafHash</code>\nTagged hash used in taproot trees.\nBIP-342 tapscript.\nTaproot Tree representing a complete binary tree without …\nTaproot-tagged hash with tag &quot;TapTweak&quot;.\nThe tag used for <code>TapTweakHash</code>\nBuilder for building taproot iteratively. Users can …\nDetailed error type for taproot builder.\nDetailed error type for taproot utilities.\nThe merkle proof for inclusion of a tree in a taptree hash.\nRepresents taproot spending information.\nAdds a hidden/omitted node at <code>depth</code> to the builder. Errors …\nAdds a leaf script at <code>depth</code> to the builder with default …\nAdds a leaf script at <code>depth</code> to the builder with script …\nObtains the hidden leaf hash if the leaf is hidden.\nReturns a reference to the inner vector of hashes.\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nReturns a reference to the inner hash (sha256, sh256d …\nObtains a reference to script and version if the leaf is …\nReturns the internal script map.\nAssumes the given 32 byte array as hidden <code>TapNodeHash</code>.\nCombines two <code>NodeInfo</code> to create a new parent.\nConstructs a <code>ControlBlock</code> for particular script with the …\nDecodes bytes from control block.\nDecodes bytes representing a <code>ControlBlock</code>.\nReturns the depth of this script leaf in the tap tree.\nSerializes to a writer.\nSerializes to a writer.\nCreates a <code>TaprootSpendInfo</code> with the given internal key.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>LeafVersion</code> from consensus byte representation.\nCreates a new BIP341 <code>TapTweakHash</code> from key and tweak. …\nObtains a script leaf from the leaf node if the leaf is …\nComputes branch hash given two hashes of the nodes …\nComputes the <code>TaprootSpendInfo</code> from <code>internal_key</code> and <code>node</code>.\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nCreates this wrapper type from the inner hash type.\nComputes the leaf hash from components.\nComputes the <code>TapNodeHash</code> from a script and a leaf version.\nDeserialize from slice\nChecks if the builder has hidden nodes.\nThe corresponding hash type\nReturns the internal key for this <code>TaprootSpendInfo</code>.\nThe internal key.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts error into the original incomplete <code>TaprootBuilder</code> …\nReturns the inner list of hashes.\nConverts error into the original incomplete <code>NodeInfo</code> …\nGets the inner <code>NodeInfo</code> of this tree root.\nChecks if this merkle proof is empty.\nChecks if the builder has finalized building a tree.\nReturns a reference to the leaf of this <code>ScriptLeaf</code>.\nComputes a leaf hash for this <code>ScriptLeaf</code> if the leaf is …\nCreates an iterator over all leaves (including hidden …\nReturns leaf version of the script if the leaf is known.\nThe tapleaf version.\nReturns the number of nodes in this merkle proof.\nReturns reference to the merkle proof (hashing partners) …\nObtains a reference to the merkle proof of the leaf.\nThe merkle proof of a script associated with this leaf.\nReturns the merkle root for this <code>TaprootSpendInfo</code>.\nCreates a new instance of <code>TaprootBuilder</code>.\nCreates an new <code>ScriptLeaf</code> from <code>hash</code> and no merkle branch.\nCreates a new <code>NodeInfo</code> with omitted/hidden info.\nCreates a new key spend with <code>internal_key</code> and <code>merkle_root</code>. …\nCreates a new leaf <code>NodeInfo</code> with given <code>ScriptBuf</code> and …\nCreates an new <code>ScriptLeaf</code> from <code>script</code> and <code>ver</code> and no …\nComputes the <code>TapNodeHash</code> for this <code>ScriptLeaf</code>. This returns …\nGets the reference to inner <code>NodeInfo</code> of this tree root.\nReturns the output key (the key used in script pubkey) for …\nReturns the parity of the output key. See also …\nThe parity of the output key (NOT THE INTERNAL KEY WHICH …\nReturns reference to the leaf script if the leaf is known.\nObtains a reference to the script inside the leaf.\nReturns [<code>TapTreeIter&lt;&#39;_&gt;</code>] iterator for a taproot script …\nReturns a reference to the internal script map.\nSerializes <code>self</code> as bytes.\nSerializes the control block.\nThe underlying schnorr signature\nReturns the size of control block. Faster and more …\nReturns the <code>TapTweakHash</code> for this <code>TaprootSpendInfo</code> i.e., …\nReturns the consensus representation of this …\nReturns the consensus representation of this <code>LeafVersion</code>.\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nReturns the inner hash (sha256, sh256d etc.).\nConverts a <code>TapTweakHash</code> into a <code>Scalar</code> ready for use with …\nSerialize Signature\nConstructs <code>TapTree</code> from a <code>NodeInfo</code> if it is complete …\nConstructs <code>TapTree</code> from a <code>TaprootBuilder</code> if it is complete …\nCreates a merkle proof from list of hashes.\nCreates a merkle proof from list of hashes.\nCreates a merkle proof from list of hashes.\nConverts the builder into a <code>NodeInfo</code> if the builder is a …\nConverts the builder into a <code>TapTree</code> if the builder is a …\nVerifies that a control block is correct proof for a given …\nObtains the version of the script leaf.\nCreates a new instance of <code>TaprootBuilder</code> with a capacity …\nCreates a new <code>TaprootSpendInfo</code> from a list of scripts …\nCreates a new <code>TaprootSpendInfo</code> from a list of scripts …")