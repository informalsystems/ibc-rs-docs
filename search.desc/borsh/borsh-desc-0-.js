searchState.loadedDescShard("borsh", 0, "Crate features\nDerive macro available if borsh is built with …\nDerive macro available if borsh is built with …\nDerive macro available if borsh is built with …\nSubset of <code>std::io</code> which is used as part of borsh public …\nReturns the largest possible size of a serialised object …\nSerializes an object without allocation to compute and …\nModule is available if borsh is built with …\ngenerate BorshSchemaContainer for type <code>T</code>\nSerialize an object into a vector of bytes.\nSerializes an object directly into a <code>Writer</code>.\nDeserialize this instance from a slice of bytes, but …\nSerialize object into a vector of bytes and prefix with …\nA data-structure that can be de-serialized from binary …\nAdditional methods offered on enums which is used by …\nDeserializes this instance from a given slice of bytes. …\nDeserialises given variant of an enum from the reader.\nDeserializes an object from a reader.\nDeserializes an object from a slice of bytes.\nModule is available if borsh is built with …\nDeserialize this instance from a slice of bytes.\nA socket address could not be bound because the address is …\nA nonexistent interface was requested or the requested …\nAn entity already exists, often a file.\nProgram argument list too long.\nThe operation failed because a pipe was closed.\nThe connection was aborted (terminated) by the remote …\nThe connection was refused by the remote server.\nThe connection was reset by the remote server.\nCross-device or cross-filesystem (hard) link or rename.\nDeadlock (avoided).\nA non-empty directory was specified where an empty …\nContains the error value\nThe error type for I/O operations of the <code>Read</code>, <code>Write</code>, <code>Seek</code>…\nA list specifying general categories of I/O error.\nExecutable file is busy.\nFile larger than allowed or supported.\nLoop in the filesystem or IO subsystem; often, too many …\nFilesystem quota was exceeded.\nThe remote host is not reachable.\nThe operation was partially successful and needs to be …\nThis operation was interrupted.\nData not valid for the operation were encountered.\nA filename was invalid.\nA parameter was incorrect.\nThe filesystem object is, unexpectedly, a directory.\nThe system’s networking is down.\nThe network containing the remote host is not reachable.\nA filesystem object is, unexpectedly, not a directory.\nThe network operation failed because it was not connected …\nAn entity was not found, often a file.\nSeek on unseekable file.\nContains the success value\nA custom error that does not fall under any other I/O …\nAn operation could not be completed, because it failed to …\nThe operation lacked the necessary privileges to complete.\nThe <code>Read</code> trait allows for reading bytes from a source.\nThe filesystem or storage medium is read-only, but a write …\nResource is busy.\nA specialized <code>Result</code> type for I/O operations.\nStale network file handle.\nThe underlying storage (typically, a filesystem) is full.\nThe I/O operation’s timeout expired, causing it to be …\nToo many (hard) links to the same filesystem object.\nAn error returned when an operation could not be completed …\nThis operation is unsupported on this platform.\nThe operation needs to block to complete, but the blocking …\nA trait for objects which are byte-oriented sinks.\nAn error returned when an operation could not be completed …\nCreates a “by reference” adaptor for this instance of …\nCreates a “by reference” adapter for this instance of …\nTransforms this <code>Read</code> instance to an <code>Iterator</code> over its …\nCreates an adapter which will chain this stream with …\nAttempts to downcast the custom boxed error to <code>E</code>.\nFlushes this output stream, ensuring that all …\nShows a human-readable description of the <code>ErrorKind</code>.\nConverts an <code>ErrorKind</code> into an <code>Error</code>.\nConverts a <code>alloc::ffi::NulError</code> into a <code>Error</code>.\nReturns the argument unchanged.\nConverts <code>TryReserveError</code> to an error with …\nReturns the argument unchanged.\nCreates a new instance of an <code>Error</code> from a particular OS …\nReturns a mutable reference to the inner error wrapped by …\nReturns a reference to the inner error wrapped by this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the <code>Error</code>, returning its inner error (if any).\nDetermines if this <code>Read</code>er has an efficient <code>read_vectored</code> …\nDetermines if this <code>Write</code>r has an efficient <code>write_vectored</code> …\nReturns the corresponding <code>ErrorKind</code> for this error.\nReturns an error representing the last OS error which …\nCreates a new I/O error from a known kind of error as well …\nCreates a new I/O error from an arbitrary error payload.\nReturns the OS error that this error represents (if any).\nPull some bytes from this source into the specified …\nPull some bytes from this source into the specified buffer.\nReads the exact number of bytes required to fill <code>cursor</code>.\nReads the exact number of bytes required to fill <code>buf</code>.\nReads all bytes until EOF in this source, placing them …\nReads all bytes until EOF in this source, appending them …\nLike <code>read</code>, except that it reads into a slice of buffers.\nCreates an adapter which will read at most <code>limit</code> bytes …\nWrites a buffer into this writer, returning how many bytes …\nAttempts to write an entire buffer into this writer.\nAttempts to write multiple buffers into this writer.\nWrites a formatted string into this writer, returning any …\nLike <code>write</code>, except that it writes from a slice of buffers.\nArray length isn’t present in payload, it’s determined …\nThe declaration and the definition of the type that can be …\nAll schema information needed to deserialize a single type.\nConvenience constant representing the length range of a …\nConvenience constant representing the length width of a …\nThe type that we use to represent the declaration of the …\nThe type that we use to represent the definition of the …\nThe type that we use for value of discriminant.\nThe struct with no fields, structurally identical to an …\nA Sequence defined with an empty length range.\nA possibly tagged union, a.k.a enum.\nThe name of the field in the struct (can be used to …\nThe collection representing the fields of a struct.\nSome of the declared types were lacking definition making …\nSome of the declared types were lacking definition, which …\nThe struct with named fields, structurally identical to a …\nThe theoretical maximum size of the encoded value …\nA fixed-size type, which is considered undivisible\nThe type is recursive and thus theoretical maximum size is …\nPossible error when validating a <code>BorshSchemaContainer</code>, …\nPossible error when calculating theoretical maximum size …\nA sequence of homogeneous elements.\nA structure, structurally similar to a tuple.\nonly 0, 1, 2, 4 and 8 bytes long sequences’ <code>length_width</code> …\nDeclared tag width is too small.  Tags must be large …\nDeclared tag width is too large.  Tags may be at most …\nA fixed-size tuple with the length known at the compile …\nThe struct with unnamed fields, structurally identical to …\nThe type that we use for the name of the variant.\nsequences of zero-sized types of dynamic length are …\nHelper method to add a single type definition to the map.\nRecursively, using DFS, add type definitions required for …\nGet the name of the type without brackets.\ngenerate BorshSchemaContainer for type <code>T</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nModule is available if borsh is built with …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the largest possible size of a serialised object …\nValidates container for violation of any well-known rules …\nType of each element of the sequence.\nBounds on the possible lengths of the sequence.\nHow many bytes does the length tag occupy.\nWidth in bytes of the discriminant tag.\nPossible variants of the enumeration. <code>VariantName</code> is …\nA data-structure that can be serialized into binary format …\nModule is available if borsh is built with …")