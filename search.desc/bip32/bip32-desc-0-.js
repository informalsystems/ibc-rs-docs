searchState.loadedDescShard("bip32", 0, "BIP32: HD Wallets\nSize of a child number when encoded as bytes.\nSize of an extended key when deserialized into bytes from …\nBase58 errors.\nBIP39-related errors.\nChain code: extension for both private and public keys …\nIndex of a particular child key for a given (extended) …\nChild number-related errors.\nCryptographic errors.\nDecoding errors (not related to Base58).\nDerivation depth.\nMaximum derivation depth exceeded.\nDerivation paths within a hierarchical keyspace.\nEnglish is presently the only supported language\nContains the error value\nError type.\nSerialized extended key (e.g. <code>xprv</code> and <code>xpub</code>).\nExtended key attributes: fields common to extended keys …\nExtended private keys derived using BIP32.\nExtended public keys derived using BIP32.\nHardened child keys use indices 2^31 through 2^32-1.\nSize of input key material and derived keys.\nBIP32 key fingerprints.\nLength of a prefix in ASCII characters.\nSupported languages.\nMaximum size of a Base58Check-encoded extended key in …\nMaximum derivation depth.\nBIP39 mnemonic phrases: sequences of words representing …\nContains the success value\nBIP32 extended key prefixes a.k.a. “versions” (e.g. …\nTrait for key types which can be derived using BIP32.\nBytes which represent a private key.\nTrait for key types which can be derived using BIP32.\nPublic key type which corresponds to this private key.\nBytes which represent a public key.\nResult type.\nNumber of bytes of PBKDF2 output to extract.\nBIP39 seeds.\nSeed length invalid.\n<code>tprv</code> prefix\n<code>tpub</code> prefix\nBIP32 “versions”: integer representation of the key …\n<code>xprv</code> prefix\n<code>xpub</code> prefix\nExtended private secp256k1 ECDSA signing key.\nExtended public secp256k1 ECDSA verification key.\n<code>yprv</code> prefix\n<code>ypub</code> prefix\n<code>zprv</code> prefix\n<code>zpub</code> prefix\nGet the inner secret byte slice\nGet the prefix as a string.\nGet attributes for this key such as depth, parent …\nGet attributes for this key such as depth, parent …\nExtended key attributes.\nChain code.\nChild number.\nDepth in the key derivation hierarchy.\nDerive a child key from a parent key and the a provided …\nDerive a child key from a parent key and a provided tweak …\nDerive a child key for a particular <code>ChildNumber</code>.\nDerive a child key for a particular <code>ChildNumber</code>.\nDerive a child key from the given <code>DerivationPath</code>.\nDerive a tweak value that can be used to generate the …\nDerive a tweak value that can be used to generate the …\nDerive a tweak value that can be used to generate the …\nDerive a tweak value that can be used to generate the …\nGet source entropy for this phrase.\nCompute a 4-byte key fingerprint for this public key.\nCompute a 4-byte key fingerprint for this public key.\nCompute a 4-byte key fingerprint for this extended public …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialize this key from bytes.\nInitialize this key from bytes.\nParse a child number from the byte encoding.\nCreate a new prefix from the given encoded bytes.\nCreate a new BIP39 mnemonic phrase from the given entropy\nCreate a new prefix from the given 4-character string and …\nGet the index number for this <code>ChildNumber</code>, i.e. with …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this derivation path empty? (i.e. the root)\nIs this child number within the hardened range?\nIs this a private key?\nIs this a public key?\nIterate over the <code>ChildNumber</code> values in this derivation …\nKey material (may be public or private).\nLanguage this phrase’s wordlist is for\nGet the count of <code>ChildNumber</code> values in this derivation …\nCreate a new seed from the given bytes.\nCreate new <code>ChildNumber</code> with the given index and hardened …\nCreate the root extended key for the given seed value.\nCreate a new extended public key from a public key and …\nCreate a new BIP39 mnemonic phrase from the given string.\nGet the parent <code>DerivationPath</code> for the current one.\nParent fingerprint.\nGet the mnemonic phrase as a string reference.\n<code>Prefix</code> (a.k.a. “version”) of the key (e.g. <code>xprv</code>, <code>xpub</code>)\nBorrow the derived private key value.\nGet the <code>Self::PublicKey</code> that corresponds to this private …\nSerialize the derived public key as bytes.\nObtain the non-extended public key value <code>K</code>.\nPush a <code>ChildNumber</code> onto an existing derivation path.\nCreate a random BIP39 mnemonic phrase.\nSerialize this key as bytes.\nSerialize this key as bytes.\nSerialize this child number as bytes.\nSerialize the raw private key as a byte array.\nSerialize the raw public key as a byte array (e.g. …\nSerialize the <code>Version</code> number as big-endian bytes.\nSerialize this key as an <code>ExtendedKey</code>.\nSerialize this key as an <code>ExtendedKey</code>.\nConvert this mnemonic phrase into the BIP39 seed value.\nSerialize this key as a self-<code>Zeroizing</code> <code>String</code>.\nSerialize this key as a <code>String</code>.\nGet the <code>Version</code> number.\nWrite a Base58-encoded key to the provided buffer, …")