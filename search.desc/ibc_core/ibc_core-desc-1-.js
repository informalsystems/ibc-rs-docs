searchState.loadedDescShard("ibc_core", 1, "Allocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nConverts a clone-on-write slice into a vector.\nConverts a boxed slice into a vector by transferring …\nAllocates a <code>Vec&lt;T&gt;</code> and moves <code>s</code>’s items into it.\nReturns the argument unchanged.\nConverts a <code>BinaryHeap&lt;T&gt;</code> into a <code>Vec&lt;T&gt;</code>.\nTurn a <code>VecDeque&lt;T&gt;</code> into a <code>Vec&lt;T&gt;</code>.\nConverts a <code>CString</code> into a Vec&lt;u8&gt;.\nConverts the given <code>String</code> to a vector <code>Vec</code> that holds …\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nAllocates a <code>Vec&lt;u8&gt;</code> and fills it with a UTF-8 string.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>Vec&lt;T&gt;</code> directly from a <code>NonNull</code> pointer, a …\nCreates a <code>Vec&lt;T, A&gt;</code> directly from a <code>NonNull</code> pointer, a …\nCreates a <code>Vec&lt;T&gt;</code> directly from a pointer, a length, and a …\nCreates a <code>Vec&lt;T, A&gt;</code> directly from a pointer, a length, a …\nInserts an element at position <code>index</code> within the vector, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the vector into <code>Box&lt;[T]&gt;</code>.\nTakes a <code>Vec&lt;[T; N]&gt;</code> and flattens it into a <code>Vec&lt;T&gt;</code>.\nCreates a consuming iterator, that is, one that moves each …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nReturns <code>true</code> if the vector contains no elements.\nKeep unyielded elements in the source <code>Vec</code>.\nConsumes and leaks the <code>Vec</code>, returning a mutable reference …\nReturns the number of elements in the vector, also …\nConstructs a new, empty <code>Vec&lt;T&gt;</code>.\nConstructs a new, empty <code>Vec&lt;T, A&gt;</code>.\nRemoves the last element from a vector and returns it, or …\nRemoves and returns the last element in a vector if the …\nAppends an element to the back of a collection.\nAppends an element if there is sufficient spare capacity, …\nRemoves and returns the element at position <code>index</code> within …\nReserves capacity for at least <code>additional</code> more elements to …\nReserves the minimum capacity for at least <code>additional</code> more …\nResizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.\nResizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.\nRetains only the elements specified by the predicate.\nRetains only the elements specified by the predicate, …\nForces the length of the vector to <code>new_len</code>.\nShrinks the capacity of the vector with a lower bound.\nShrinks the capacity of the vector as much as possible.\nReturns the remaining spare capacity of the vector as a …\nCreates a splicing iterator that replaces the specified …\nReturns vector content as a slice of <code>T</code>, along with the …\nSplits the collection into two at the given index.\nRemoves an element from the vector and returns it.\nShortens the vector, keeping the first <code>len</code> elements and …\nTries to reserve capacity for at least <code>additional</code> more …\nTries to reserve the minimum capacity for at least …\nConstructs a new, empty <code>Vec&lt;T&gt;</code> with at least the specified …\nConstructs a new, empty <code>Vec&lt;T, A&gt;</code> with at least the …\nConstructs a new, empty <code>Vec&lt;T&gt;</code> with at least the specified …\nConstructs a new, empty <code>Vec&lt;T, A&gt;</code> with at least the …\n“Best effort” zeroization for <code>Vec</code>.\n<code>Any</code> contains an arbitrary serialized protocol buffer …\nA Duration represents a signed, fixed-length span of time …\nAllows for easy Google Protocol Buffers encoding and …\nA Timestamp represents a point in time independent of any …\nConstructor that attempts to decode an instance from a …\nConstructor that attempts to decode a length-delimited …\nConstructor that attempts to decode a Protobuf-encoded …\nConstructor that attempts to decode a Protobuf-encoded …\nEncode into a buffer in Protobuf format.\nEncode with a length-delimiter to a buffer in Protobuf …\nEncode with a length-delimiter to a <code>Vec&lt;u8&gt;</code> …\nEncodes into a Protobuf-encoded <code>Vec&lt;u8&gt;</code>.\nReturns the encoded length of the message without a length …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSerialize the given message type <code>M</code> as <code>Any</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSigned fractions of a second at nanosecond resolution of …\nNon-negative fractions of a second at nanosecond …\nNormalizes the duration to a canonical format.\nNormalizes the timestamp to a canonical format.\nSigned seconds of the span of time. Must be from …\nRepresents seconds of UTC time since Unix epoch …\nDecode the given message type <code>M</code> from <code>Any</code>, validating that …\nConverts a <code>core::time::Duration</code> to a <code>Duration</code>, failing if …\nA URL/resource name that uniquely identifies the type of …\nMust be a valid serialized protocol buffer of the above …\nA slice type that implements the <code>Display</code> trait to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPretty printing utilities.\nA slice type that implements the <code>Display</code> trait to …\nDefines the <code>Router</code>, which binds modules to ports\nRe-exports router data structures from the …\nICS-26 <code>onRecvPacket</code> callback implementation.\nNote: <code>MsgTimeout</code> and <code>MsgTimeoutOnClose</code> use the same …\nNote: <code>MsgTimeout</code> and <code>MsgTimeoutOnClose</code> use the same …\nRouter as defined in ICS-26, which binds modules to ports.\nReturns a reference to a <code>Module</code> registered against the …\nReturns a mutable reference to a <code>Module</code> registered against …\nReturn the module_id associated with a given port_id\nhost error: {0}\nmissing module\nError type for the router module.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe event type emitted by IBC applications\nA single key/value pair in a <code>ModuleEvent</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLogs and events produced during module callbacks\nModule name, internal to the chain.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")