searchState.loadedDescShard("ark_ec", 0, "Affine representation of an elliptic curve point …\nThe base field that hosts G1.\nThe extension field that hosts G2.\nThe extension field that hosts the target group of the …\nThis is the scalar field of the G1/G2 groups.\nThe affine representation of an element in G1.\nA G1 element that has been preprocessed for use in a …\nThe projective representation of an element in G1.\nThe affine representation of an element in G2.\nA G2 element that has been preprocessed for use in a …\nThe projective representation of an element in G2.\nProjective representation of an elliptic curve point …\nSet <code>self</code> to be <code>self + other</code>, where <code>other: Self::Affine</code>. …\nSet <code>self</code> to be <code>self + other</code>, where <code>other: Self::Affine</code>. …\nNormalizes a slice of projective elements so that …\nNormalizes a slice of projective elements and outputs a …\nDoubles this element.\nDoubles this element in place.\nPerform final exponentiation of the result of a miller …\nReturns a group element if the set of bytes forms a valid …\nConverts self into the affine representation.\nConverts self into the projective representation.\nChecks if the point is already “normalized” so that …\nCompute the product of miller loops for some number of …\nPerforms scalar multiplication of this element with mixed …\nPerforms scalar multiplication of this element.\nMultiply this element by the cofactor.\nMultiply this element by the inverse of the cofactor in …\nMultiply this element by the cofactor and output the …\nPerforms multiple pairing operations\nPreprocess a G1 element for use in a pairing.\nPreprocess a G2 element for use in a pairing.\nReturns a fixed generator of unknown exponent.\nReturns a fixed generator of unknown exponent.\nComputes a product of pairings.\nReturns <code>self + self</code>.\nSets <code>self := self + self</code>.\nWhat kind of twist is this?\nA particular BLS12 group can have G2 being either a …\nParameterizes the BLS12 family.\nIs <code>Self::X</code> negative?\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAffine coordinates for a point on an elliptic curve in …\nJacobian coordinates for a point on an elliptic curve in …\nWhen <code>other.is_normalized()</code> (i.e., <code>other.z == 1</code>), we can …\nNormalizes a slice of projective elements so that …\nSets <code>self = 2 * self</code>. Note that Jacobian formulae are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to construct an affine point given an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if <code>self</code> is in the subgroup having order that …\nChecks if <code>self</code> is a valid point on the curve.\nChecks if <code>self</code> is the point at infinity.\nChecks whether <code>self.z.is_zero()</code>.\nIf <code>self.is_zero()</code>, returns <code>self</code> (<code>== Self::zero()</code>). Else, …\nMultiply <code>self</code> by the cofactor of the curve, <code>P::COFACTOR</code>.\nReturns the point at infinity. Note that in affine …\nReturns the point at infinity, which always has Z = 0.\n<code>GroupProjective</code> implements Extended Twisted Edwards …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to construct an affine point given an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks that the current point is in the prime order …\nChecks that the current point is on the elliptic curve.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA helper type that contains all the context required for …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nComputes scalar multiplication of a group element <code>g</code> by …\nComputes scalar multiplication of a group element by <code>scalar</code>…\nConstruct a new context for a window of size <code>window_size</code>.")